***
*** FILE: APD.ASM
***
*** GSP DMA OBJECT HANDLER
*** VERSION 1.0 BY WARREN DAVIS 9/1/87
*** VERSION 2.01 BY EUGENE JARVIS 10/25/87
*** VERSION 3.0 BY EUGENE JARVIS 12/20/87
*** VERSION 3.1 BY EUGENE JARVIS 7/4/88
*** VERSION 3.2 BY EUGENE JARVIS 8/8/88
*** VERSION 3.3 BY TODD ALLEN 3/26/89
*** VERSION 4.0 BY TODD ALLEN 10/20/90
*** JFL 17 JUL 92
*** JFL 20 JUL 92
*** JFL 21 JUL 92
*** JFL 22 JUL 92
*** JFL 27 JUL 92
*** JFL 28 JUL 92
*** JFL 29 JUL 92
*** JFL 17 AUG 92; LET Y GO NEG TO -OBJECTYMAX
*** JFL 18 AUG 92; DMAWAIT
*** JFL 20 AUG 92
*** JFL 21 AUG 92; VIEWLEFTRIGHT
*** JFL 13 SEP 92; SCALE FIX
*** JFL 14 SEP 92; GRAVITY
*** JFL 16 SEP 92; SCREEN BASED Z
*** JFL 30 SEP 92; NEW SCORE
*** JFL 01 OCT 92
*** JFL 02 OCT 92; SHADOW
*** JFL 04 OCT 92; IMPROVED SHADOW
*** JFL 05 OCT 92; NEW DMAQ
*** JFL 14 OCT 92
*** JFL 15 JAN 93; ASSERT
*** JFL 24 JAN 93; HOUSE CLEANING PASS
*** JFL/JMS 12 APR 93; MERGE
***

 	.MLIB	"APMACS.LIB"
	.FILE	"APD.ASM"
	.TITLE	"<<< AMUSMENT PARK -- DISPLAY PROCESSOR VER. 4.0 >>>"
	.WIDTH	132
	.OPTION	B,D,L,T
	.MNOLIST

**
** COMPILE FLAGS
**
SCALECARVELS	EQU	1	;SCALE VELOCITIES
SCALEOBJVELS	EQU	1	;SCALE VELOCITIES
NLINEARSCALE	EQU	1	;NON-LINEAR SCALING FOR CAR

**************************************************************************
*								         *
* 	COPYRIGHT (C) 1992 MIDWAY MANUFACTURING COMPANY.		 *
* 		       ALL RIGHTS RESERVED.				 *
*								         *
**************************************************************************



****************************************
*FILES REQUIRED FOR ASSEMBLY
	.include	"AP.H"
	.INCLUDE	"DRFGHOST.I"

	.GLOBL	CkOFREE,ISOBJ


** OTHERS USE
	.DEF	CKINSANI	;APD.ASM
	.DEF	INSANI		;APD.ASM
	.DEF	PULLSUPP	;APD.ASM
	.DEF	FREEOBJ
	.DEF	OFREECNT
	.DEF	VELADD		;APD.ASM
	.DEF	VELADDCAR	;APD.ASM
	.DEF	VELSUBCAR	;APD.ASM
	.DEF	SCORELIST	;APD.ASM
	.DEF	SHADOWLIST	;APD.ASM
	.DEF	DEBUGDMALIST	;APD.ASM
	.DEF	CREATE_COPY	;APD.ASM
	.DEF	DMAVCOUNT	;APD.ASM
	.DEF	INITDISPLAYLISTS ;APD.ASM
	.DEF	SHAKEXY		;APD.ASM
	.DEF	IsAnObj		;APD.ASM
	.DEF	FREEDISPLAYLIST	;APD.ASM
	.DEF	FREEALLOBJS	;APD.ASM
	.DEF	BOG		;APD.ASM
	.DEF	INSBOBJ		;APD.ASM
	.DEF	DMAQPRE0	;APD.ASM
	.DEF	DMAQSTR0	;APD.ASM
	.DEF	DMAQBOT0	;APD.ASM
	.DEF	DMAQPRE1	;APD.ASM
	.DEF	DMAQSTR1	;APD.ASM
	.DEF	DMAQBOT1	;APD.ASM
	.DEF	DMAQBOT		;APD.ASM
	.DEF	DMAQPRE		;APD.ASM
	.DEF	INITDMAQ	;APD.ASM
	.DEF	DISPLISTPREQ	;APD.ASM
	.DEF	PREQLIST	;APD.ASM	
	.DEF	INSVLIST	;APD.ASM
	.DEF	PULLVLIST	;APD.ASM
	.DEF	INSERT_OBJ	;APD.ASM
	.DEF	PULLANIM	;APD.ASM
	.DEF	CKPULLANIM	;APD.ASM
	.DEF	SETGCOL		;APD.ASM
	.DEF	CLRGCOL		;APD.ASM
	.DEF	GCOLWATCHER	;APD.ASM
	.DEF	FGLISTS		;APD.ASM

** WE USE
	.REF	MAKESHADOWS	;APC.ASM
	.REF	MAKEFOREGROUND	;APC.ASM
	.REF	MAKEBACKGROUND	;APC.ASM
	.REF	DISPLAYPLANE	;APC.ASM
	.REF	WHCHECKFRAME	;DRH.ASM
	.REF	IN_ANIM		;APC.ASM
	.REF	PAGE
	.REF	PAGEADDR
	.IF DEBUG
	.REF	DEBUGOBJ	;DR.ASM
	.ENDIF ;DEBUG

** WE USE -- RAM
	.REF	GCOLLIST	;DRRAM.ASM
	.REF	AUTOVELLIST	;DRRAM.ASM
	.REF	GCOLLIST	;DRRAM.ASM
	.REF	J64Q		;DRRAM.ASM

**
** DEFINES
**
QSIZE	.SET	NOBJ*BQCELL		;SIZE OF A QUEUE

**************************************************************************
* VARIABLES STUCK IN RAM (.SECT "OFIXED")
*
	.SECT	"OFIXED"

;* OBJ PLANES HAVE FOLLOWING STUCTURE
;      ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
;      ≥⁄ƒƒƒƒƒƒƒƒø⁄ƒƒƒƒƒƒƒƒƒƒø⁄ƒƒƒƒƒƒƒƒƒƒø≥
;     …ÕÀÕÕª   …ÕÀÕÕÀÕÕ   …ÕÀÕÕÀÕÕ   …ÕÀÕÕÀÕÕ
;     ∫  ∫  ∫   ∫  ∫  ∫     ∫  ∫  ∫     ∫  ∫  ∫  
;     »Õ ÕÕº   »Õ ÕÕ ÕÕ   »Õ ÕÕ ÕÕ   »Õ ÕÕ ÕÕ
;       ¿ƒƒ≈ƒƒƒƒƒƒ≈ƒƒŸ        ¿ƒƒ≈ƒƒƒƒƒƒƒƒ≈ƒƒŸ
;          ≥      ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ        ≥
;          ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ


L7	.MACRO
	.SPACE	PLNSIZ
	.ENDM
FGLISTS
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
FGLISTSX

BGLISTS
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
	L7
BGLISTSX

PREQLIST
	L7
DEBUGDMALIST
	L7
SCORELIST
	L7
SHADOWLIST
	L7

;# OF ENTRIES MUST = 2**#bits of SUPP field in OID
SUPPLSTS
	.long	0,0,0,0,0,0,0,0
	.long	0,0,0,0,0,0,0,0
SUPPLSTSX

OFREE		.LONG	0	;LIST OF FREE OBJECTS
ENDOFREE	.LONG	0	;PTR TO LAST OBJ ON FREE LIST
ANIOBJS		.LONG	0	;LIST OF OBJECTS FOR ANIM PROCESS

	.BSS	ANIFUNCS,040h*NOBJ+020h,1 ;list of ANIM FUNCTIONS TO BE CALLED
					;+020h for list terminating 0
	.BSS	ANIFUNCSX,0
	.def	ANIFUNCSX

	.def	CPUCHK1,CPUCHK2,CPUCHK3,CPUCHK4,CPUCHK5,CPUCHK0
	.def	CLIPTIM,VELTIM,SCALETIM,PROCTIM
*
  	.BSS	CLIPTIM,16 		; % OF SCREEN TIME FOR CLIP LOOP
  	.BSS	VELTIM,16		; % OF SCREEN TIME FOR VEL LOOP
  	.BSS	SCALETIM,16		; % OF SCREEN TIME FOR SCALE
  	.BSS	PROCTIM,16		; % OF SCREEN TIME FOR PROCESSES
  	.BSS	CPUCHK0,16		; VLINE AT START OF DIRQ
  	.BSS	CPUCHK1,16		; VLINE BEFORE CLIP/DMA STARTED
  	.BSS	CPUCHK2,16		; VLINE BEFORE VELADD STARTED
  	.BSS	CPUCHK3,16		; VLINE BEFORE SCALE_MAMA STARTED
  	.BSS	CPUCHK4,16		; VLINE AFTER SCALE_MAMA DONE
  	.BSS	CPUCHK5,16		; VLINE AT END OF PROCESSES
  	.BSS	DMAOVER,16		; VLINE AT WHICH DMA IS DONE FOR FRAME
  	.BSS	SKYTOP,16		; VLINE OF TOP OF SKY (0 OR SKYTOPOF)
  	.BSS	HORIZON,16		; VLINE SEPARATING SKY FROM GROUND.
  	.BSS	BGPLANECT,16		;# OF BGND PLANES
  	.BSS	FGPLANECT,16		;# OF FGND PLANES
  	.BSS	SCROLLX,32		;X SCROLL VALUE
  	.BSS	SCROLLY,32		;Y SCROLL VALUE
	.BSS	SHAKEXY,32		;Y:X SHAKE VALUE
  	.BSS	SCRNTL,32		;TOP LEFT [Y,X] SCREEN (SCRN COORD.)
  	.BSS	SCRNLR,32		;LOWER RIGHT [Y,X] SCREEN (SCRN COORD.)
  	.BSS	OFREECNT,16		;# OBJECTS ON FREE LIST
  	.BSS	OBJSTR,NOBJ*OBSIZ	;OBJECT SPACE START
  	.BSS	OBJSTRX,0		;OBJECT SPACE END
  	.BSS	DMAQCUR,32		;CURRENT DMAQ
  	.BSS	DMAQ,QSIZE		;MISC. NON-SYNC DMA QUEUE
  	.BSS	QDMAFLG,16		;SPECIAL DMAQ BEING UPDATED=1
  	.BSS	DISPLAYON,16		;VV KEEP TOGETHER
	.BSS	DMAVCOUNT,16
	.BSS	BOG,16			;^^ KEEP TOGETHER

  	.BSS	DMAQSTR0,NOBJ*6*020H	;SPACE TO STORE DMAINT Q
  	.BSS	DMAQBOT0,0		;
  	.BSS	DMAQSTR1,NOBJ*6*020H	;SPACE TO STORE DMAINT Q
  	.BSS	DMAQBOT1,0		;

	.BSS	DMAQPRE0,32		;PRELOAD STUFF IN DMAQ
	.BSS	DMAQPRE1,32		;PRELOAD STUFF IN DMAQ
	.BSS	DMAQPRE,32		;IN CASE PAGE FLIP DOESNT OCCUR
	.BSS 	DMAQBOT,32		;IN CASE PAGE FLIP DOESNT OCCUR

	.BSS	SHAKEQPRE0,32		;Y:X VALUE OF SHAKE ADDED SO FAR
	.BSS	SHAKEQPRE1,32		;Y:X VALUE OF SHAKE ADDED SO FAR

  	.BSS	UNIVXMIN,16	;SHW
  	.BSS	UNIVXMAX,16	;SHW
  	.BSS	WORLDX,32	;SHL - WORLDTLX W/ NEW NAME TO FIND OLD CODE
  	.BSS	WORLDY,32	;SHL - WORLDTLY W/ NEW NAME TO FIND OLD CODE
  	.BSS	WORLDXY,32	;SHL - WORLDTL W/ NEW NAME TO FIND OLD CODE
	.BSS	DMARESTARTS,32	;UHL - TIMES DMA NEEDED RESTARTING

* LOCAL VARS

  	.TEXT

***
*** ------------------------------------------------------------------------
***

**
** DISPLAY
**
** ADD VELOCITIES, GRAVITY
** DISPLAY THE FOREGROUND BACKGROUND PLANES
** CALLED AT END OF SCREEN INTERRUPT
**
** JFL 15 JUL 92; FROM DREDD; MODS BEGIN
** JFL 20 JUL 92
** JFL 24 JAN 93
**
DISPLAY

	;
	;HANDLE MANUAL DMA Q
	;

	MOVL	@DMAQCUR,A8
	MOVI	DMAQ+QSIZE,A1
	CMP	A1,A8
	JREQ	DISPMANX      	;NONE
	MOVL	A1,@DMAQCUR	;RESET TOP OF QUEUE

	;ONLY TIME DMA CAN BE BUSY IS ON DMA BOG, HOLD DISPLAY
	MOVW	@DMACTRL,A0
	JRN	DISPMANX	;WE MUST BE HOLDING THE LAST FRAME

	TLOCKUP ;BETTER THINK THIS THROUGH

	;DONT ALLOW DMA INT
	SETF	1,0,0
	MOVE	SP,@(INTENB+B_X1E),0	;X1E
	SETF	16,1,0
	
DMANLP
 	SUBI	32*6,A1		;WFD -- BACKUP IN DMAQ ONE ENTRY
	MOVE	A1,A0
	MMFM	A0,A14,A6,A5,A4,A3,A2

	;WAIT A REASONABLE TIME FOR DMA TO FINISH
	MOVI	26000/8,A0
DISPMW0
	MOVW	@DMACTRL,A14
	JRNN	DISPMW1
	DSJ	A0,DISPMW0
	MOVW	A0,@DMACTRL
	MOVW	A0,@DMACTRL
	TLOCKUP
	JRUC	DISPM2X
DISPMW1

	;STUFF DMA REGS
	;A14,A6,A5,A4,A3,A2 CTRL:OFSET,SAG,DAG,Y:XSIZ,CONST:PAL,Y:XSCALE
	MOVI	DMAREGS,A7		;DMAREGS
	MMTM	A7,A2,A3,A4,A5,A6,A14
	CMP	A8,A1
	JRHI	DMANLP

DISPM2X
	;ALLOW DMA INT
	SETF	1,0,0
	MOVK	1,A14
	MOVE	A14,@(INTENB+B_X1E),0	;X1E
	SETF	16,1,0

DISPMANX

	;
	;NORMAL DISPLAY
	;


	MOVL	@PAGEADDR,B5


	;
	;RE-CALC & Q UP ALL OTHER OBJS
	;

	CALLR	PUTPLANES

DISPX
	RETS

***
*** ----------------------------------------------------------------------
***

**
** DISPLISTPREQ
**
** JFL 24 JAN 93
**
DISPLISTPREQ
	MMTM	SP,A0,A1,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13

	PUSHST
	DINT

	;MAKE SURE WE HAVE A CLEAN Q & HALTED DMA
	CALLR	INITDMAQ

	;MAKE BACKGROUND PLANE -- SETS DAG
	MOVI	PREQLIST,A0
	MOVL	*A0(P_YPOS),A1
	MOVL	*A0(P_XPOS),A2
	SRL	16,A2
	MOVX	A2,A1
	MOVL	*A0(P_XYOFF),A14
	ADDXY	A14,A1
	CALLR	MAKEBACKGROUND ;IN: A0,A1 PLANE,OFFSET Y:X

	;PAGE 0
	MOVI	PAGE0ADR,A3		;DRAW PAGE 0
	MOVI	PREQLIST,A0		;DISPLAY LIST
	MOVI	DMAQBOT0,A4		;STARTING WITH BOTTOM OF PAGE0 Q
	CALLR	BUILDPREQ ;IN:A0,A3,A4 PLANE,Y:X OFFSET,QNEXT
	MOVL	A4,@DMAQPRE0		;PRELOADED STUFF PG0 ENDS HERE
	MOVL	A4,@DMAQPRE		;PRELOADED STUFF CUR PAGE
	MOVE	A4,B12			;SETUP DMAQ

	;PAGE 1
	MOVI	PAGE1ADR,A3		;DRAW PAGE 1
	MOVI	PREQLIST,A0		;DISPLAY LIST
	MOVI	DMAQBOT1,A4		;STARTING WITH BOTTOM OF PAGE1 Q
	CALLR	BUILDPREQ ;IN:A0,A3,A4 PLANE,Y:X OFFSET,QNEXT
	MOVL	A4,@DMAQPRE1		;PRELOADED STUFF PG1 ENDS HERE

	CLR	A14
	MOVL	A14,@SHAKEQPRE0
	MOVL	A14,@SHAKEQPRE1

	POPST

DLPX
	MMFM	SP,A0,A1,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13
	RETS

**
** BUILDPREQ
**
** IN
**   A0 PLANE LIST
**   A3 PAGE Y:X OFFSET
**   A4 Q NEXT
** OUT
**   A4 Q NEXT
**
** SCRATCHES ALL A!!!
**
** JFL 24 JAN 93
**
BUILDPREQ
	MOVE	A0,A1			;COPY OF PLANE START
	MOVI	[SCRBOT,SCRRGT],A2	;VISIBLE AREA

	MOVL	*A0,A14
	TLOCKON	Z
	JRZ	BPQX

BPQLOOP
	MOVL	*A0(OBLINK),A0	 	;GET NEXT LINK
	CMP	A0,A1
	JREQ	BPQX

BPQPULL
	;PULL OBJECT INFO
	;PULL CTRL:OFSET,SAG,DAG,USIZ,CONST:PAL,SCALE,SIZ
	;NOTE: DO OFFSCREEN TEST & SIZE TEST WHEN OBJ IS SCALED: NO A7 PULL
	MOVE	A0,A14
	ADDI	ODMAPULL,A14
	MMFM	A14,A13,A12,A11,A10,A9,A8,A7

	;REG USE
	; A0 OBJ
	; A1 PLANE
	; A2 [SCRBOT,SCRRGT]
	; A3 SCREEN OFFSET
	; A4
	; A5
	; A6
	; A13-A7 CTRL:OFSET,SAG,DAG,USIZ,CONST:PAL,SCALE,SIZ
	; A14 SCRATCH

	BTST	B_INUSE+16,A13
	JRZ	BPQLOOP

	;HAS THE  OBJECT LEFT THE SCREEN
	CMPXY	A2,A11
	JRXGT	BPQLOOP
	JRYGT	BPQLOOP
	MOVE	A11,A14
	ADDXY	A7,A14
	JRXN	BPQLOOP
	JRYN	BPQLOOP

	;CHECK FOR BAD OBJECTS
	MOVI	[40H,40H],A14		;SCALE MIN VALUES
	CMPXY	A14,A8
	JRXLT	BPQLOOP
	JRYLT	BPQLOOP
	MOVI	[800H,800H],A14		;SCALE MAX VALUES
	CMPXY	A14,A8
	JRXGE	BPQLOOP
	JRYGE	BPQLOOP
	MOVI	[0,2],A14		;MIN SIZE
	CMPXY	A14,A7
	JRXLE	BPQLOOP
	JRYLE	BPQLOOP
	MOVI	[SCRBOT,SCRRGT],A14	;MAX SIZE
	CMPXY	A14,A7
	JRXGE	BPQLOOP
	JRYGE	BPQLOOP

NOCLIP
	;ADJUST FOR FLIPPING
	CLR	A14	
	BTST	B_FLIPH+16,A13
	JREQ	NOH
	MOVX	A7,A14			;ADJUST FOR H FLIP
      	DEC	A14
NOH 
	BTST	B_FLIPV+16,A13
	JREQ	NOV
 	MOVY	A7,A14			;ADJUST FOR V FLIP
	SUBI	[1,0],A14		
NOV
	ADDXY	A14,A11			;ADJUST DAG

	;ADD PAGE OFFSET
	ADDXY	A3,A11
	
	;
	;ADD OBJ TO THE Q
	;

	;Q UP ENTRY -- DONT SIGNAL IMMEDIATELY
	MMTM	A4,A13,A12,A11,A10,A9,A8
	JRUC	BPQLOOP

BPQX
	RETS

**
** VELADDCAR
** ADD VELS TO ONE CAR
**
** IN
**   A0 CAR
**
** BREAKS: A1-A11,A14
**
** NOT CALLED FROM INTERRUPT...
**
** JFL 18 AUG 92
** JFL 15 SEP 92; NEW VELADD
** JFL 18 SEP 92; SCRATCH A2,A3,A14,B0-B5
** JFL 28 SEP 92; NEW SCRATCH
** JFL 13 OCT 92
** JFL 14 OCT 92; ONE CAR
** JFL 08 JAN 93; NLINEAR SCALE
**
VELADDCAR
	    
	.IF DEBUG
	MOVL	@DEBUGOBJ,A14
	CMP	A0,A14
	JRNE	VACXXX
	NOP
VACXXX
	.ENDIF ;DEBUG

	; A0 OBJ
	; A4 PULL VAR
	; A6 MULTIPART OBJ
	; A8 SCRATCH
	;
	;LOAD 
	;A11 OFLAGS&OXXX1
	;A10 OYACC  
	; A9 OXVEL
	; A7 OYVEL
	; A5 OZVEL
	; A3 OXPOS
	; A2 OYPOS
	; A1 OZPOS
	;
	MOVE	A0,A4				;GET READY FOR PULL
	ADDI	OFLAGS,A4			;ADD IN PULL BASE
	MMFM	A4,A11,A10,A9,A7,A5,A3,A2,A1

	.IF SCALECARVELS
	;SCALE VELS
	MOVW	*A0(OSCALEMUL),A14
	JRZ	VACNOVSCALE

	.IF NLINEARSCALE
	SLL	4,A14			;SIZEOF NLINEARMULTBL
	MOVE	A14,A8			;COPY OFFSET
	ADDI	NLINEARXVELTBL,A8
	MOVW	*A8,A8			;MAPS TO BIGGER	XVEL
	ADDI	NLINEARZVELTBL,A14
	MOVW	*A14,A14		;MAPS TO SMALLER ZVEL
	.ELSE ;!NLINEARSCALE
	MOVE	A14,A8
	.ENDIF ;!NLINEARSCALE

	SETF	16,1,1			;FS1 Rs MAX BIT SIZE FOR MULTIPLIES
	SRA	8,A9			;THROW AWAY VEL RESOLUTION TO MAKE
	MPYS	A8,A9			;OXVEL
	;SRA	8,A7   			
	;MPYS	A14,A7			;OYVEL
	;SRA	8,A10			
	;MPYS	A14,A10			;OYACC
	SRA	8,A5
	MPYS	A14,A5			;OZVEL
	SETF	32,0,1			;RESTORE FS1
VACNOVSCALE
	.ENDIF ;SCALECARVELS
	
	;ADD IN SCROLL IF OBJECT IS STUCK TO FIXED SCREEN LOCATION
	BTST	B_NOSCROLL,A11
	JRZ	VACDOVEL
	MOVL	@SCROLLX,A14
	ADD	A14,A9
	MOVL	@SCROLLY,A14
	ADD	A14,A7

VACDOVEL

	;ADD VELS
	ADD	A9,A3		;ADD X VELOCITY TO XVAL
	ADD	A7,A2		;ADD Y VELOCITY TO YVAL
	ADD	A5,A1		;ADD Z VELOCITY TO ZVAL

	;FALLING?
	MOVE	A7,A7
	JRP	VACFALLING

VACFALLOK

	;PUSH NEW VALS
	MMTM	A4,A3,A2,A1

	;
	;NOW DO CAR PARTS
	;
	MOVE	A0,A6
	JRUC	VACMNEXT

VACFALLING
	MOVE	A2,A2		;HIT THE GROUND YET?
	JRN	VACFALLOK	;NO

	;SETUP OYACC & OYVEL FOR REST OF ROUTINE
	SUB	A2,A7 		;FIND DISTANCE OVERSHOT FOR MULTIPARTS
	MOVE	A7,A10
	NEG	A10		;YACC + YVAL MUST ZERO OUT AT BOTTOM

	CLR	A2		;HEAD YVAL ON GROUND
	MOVL	A2,*A0(OYACC)	;ZERO YACC FOR NEXT TIME
	JRUC	VACFALLOK

VACMULTI
	MOVE	A6,A4			;get obj base in A3 for pull of vals
	ADDI	OXVAL,A4	  	
	MMFM	A4,A3,A2,A1

	;ADD VELS
	ADD	A9,A3		;ADD X VELOCITY TO XVAL
	ADD	A7,A2		;ADD Y VELOCITY TO YVAL
	ADD	A5,A1		;ADD Z VELOCITY TO ZVAL

	;PUSH NEW VALS
	MMTM	A4,A3,A2,A1

VACMNEXT
	MOVL	*A6(OPARTS),A6
	JRNZ	VACMULTI

	;ADJUST Y VEL FOR GRAVITY-TYPE THING
	ADD	A10,A7
	MOVL	A7,*A0(OYVEL)

VACX
	RETS

**
** NLINEARVELTBL
**
** TAKE OSCALEMUL AND INDEX INTO THIS TBL 1 TO 1 TO GET NEW SCALE MUL
** USE OSCALEMUL IF OUT OF RANGE OF TBL
**
** JFL 08 JAN 93
**
NLINEARZVELTBL
** TABLE 0
	.WORD	01H,01H,01H,02H,03H,04H,04H,05H
	.WORD	06H,07H,08H,08H,09H,0AH,0BH,0CH
	.WORD	0DH,0DH,0EH,0FH,010H,011H,011H,012H
	.WORD	013H,014H,015H,015H,016H,017H,018H,019H
	.WORD	01AH,01AH,01BH,01CH,01DH,01EH,01EH,01FH
	.WORD	020H,021H,022H,022H,023H,024H,025H,026H
	.WORD	027H,027H,028H,029H,02AH,02BH,02BH,02CH
	.WORD	02DH,02EH,02FH,02FH
** TABLE 1
NLINEARXVELTBL
	.WORD	030H,031H,032H,033H,034H,034H,035H,036H
	.WORD	037H,038H,038H,039H,03AH,03BH,03CH,03CH
	.WORD	03DH,03EH,03FH,040H,041H,041H,042H,043H
	.WORD	044H,045H,045H,046H,047H,048H,049H,049H
	.WORD	04AH,04BH,04CH,04DH,04EH,04EH,04FH,050H
	.WORD	051H,052H,052H,053H,054H,055H,056H,056H
	.WORD	057H,058H,059H,05AH,05BH,05BH,05CH,05DH
	.WORD	05EH,05FH,05FH,060H,061H,062H,063H,063H
	.WORD	064H,065H,066H,067H,068H,068H,069H,06AH
	.WORD	06BH,06CH,06CH,06DH,06EH,06FH,070H,070H
	.WORD	071H,072H,073H,074H,075H,075H,076H,077H
	.WORD	078H,079H,079H,07AH,07BH,07CH,07DH,07DH
	.WORD	07EH,07FH,080H,081H,082H,082H,083H,084H
	.WORD	085H,086H,086H,087H,088H,089H,08AH,08AH
	.WORD	08BH,08CH,08DH,08EH,08FH,08FH,090H,091H
	.WORD	092H,093H,093H,094H,095H,096H,097H,097H
	.WORD	098H,099H,09AH,09BH,09CH,09CH,09DH,09EH
	.WORD	09FH,0A0H,0A0H,0A1H,0A2H,0A3H,0A4H,0A4H
	.WORD	0A5H,0A6H,0A7H,0A8H,0A9H,0A9H,0AAH,0ABH
	.WORD	0ACH,0ADH,0ADH,0AEH,0AFH,0B0H,0B1H,0B1H
	.WORD	0B2H,0B3H,0B4H,0B5H,0B6H,0B6H,0B7H,0B8H
	.WORD	0B9H,0BAH,0BAH,0BBH,0BCH,0BDH,0BEH,0BEH
	.WORD	0BFH,0C0H,0C1H,0C2H,0C3H,0C3H,0C4H,0C5H
	.WORD	0C6H,0C7H,0C7H,0C8H,0C9H,0CAH,0CBH,0CBH
	.WORD	0CCH,0CDH,0CEH,0CFH,0D0H,0D0H,0D1H,0D2H
	.WORD	0D3H,0D4H,0D4H,0D5H,0D6H,0D7H,0D8H,0D8H
	.WORD	0D9H,0DAH,0DBH,0DCH,0DDH,0DDH,0DEH,0DFH
	.WORD	0E0H,0E1H,0E1H,0E2H,0E3H,0E4H,0E5H,0E5H
	.WORD	0E6H,0E7H,0E8H,0E9H,0EAH,0EAH,0EBH,0ECH
	.WORD	0EDH,0EEH,0EEH,0EFH,0F0H,0F1H,0F2H,0F2H
	.WORD	0F3H,0F4H,0F5H,0F6H,0F7H,0F7H,0F8H,0F9H
	.WORD	0FAH,0FBH,0FBH,0FCH,0FDH,0FEH,0FFH,0FFH
	.WORD	0100H,0101H,0102H,0103H,0104H,0105H,0106H,0107H
	.WORD	0108H,0109H,010AH,010BH,010CH,010DH,010EH,010FH
	.WORD	0110H,0111H,0112H,0113H,0114H,0115H,0116H,0117H
	.WORD	0118H,0119H,011AH,011BH,011CH,011DH,011EH,011FH
	.WORD	0120H,0121H,0122H,0123H,0124H,0125H,0126H,0127H
	.WORD	0128H,0129H,012AH,012BH,012CH,012DH,012EH,012FH
	.WORD	0130H,0131H,0132H,0133H,0134H,0135H,0136H,0137H
	.WORD	0138H,0139H,013AH,013BH,013CH,013DH,013EH,013FH
	.WORD	0140H,0141H,0142H,0143H,0144H,0145H,0146H,0147H
	.WORD	0148H,0149H,014AH,014BH,014CH,014DH,014EH,014FH
	.WORD	0150H,0151H,0152H,0153H,0154H,0155H,0156H,0157H
	.WORD	0158H,0159H,015AH,015BH,015CH,015DH,015EH,015FH
	.WORD	0160H,0161H,0162H,0163H,0164H,0165H,0166H,0167H
	.WORD	0168H,0169H,016AH,016BH,016CH,016DH,016EH,016FH
	.WORD	0170H,0171H,0172H,0173H,0174H,0175H,0176H,0177H
	.WORD	0178H,0179H,017AH,017BH,017CH,017DH,017EH,017FH
	.WORD	0180H,0181H,0182H,0183H,0184H,0185H,0186H,0187H
	.WORD	0188H,0189H,018AH,018BH,018CH,018DH,018EH,018FH
	.WORD	0190H,0191H,0192H,0193H,0194H,0195H,0196H,0197H
	.WORD	0198H,0199H,019AH,019BH,019CH,019DH,019EH,019FH
	.WORD	01A0H,01A1H,01A2H,01A3H,01A4H,01A5H,01A6H,01A7H
	.WORD	01A8H,01A9H,01AAH,01ABH,01ACH,01ADH,01AEH,01AFH
	.WORD	01B0H,01B1H,01B2H,01B3H,01B4H,01B5H,01B6H,01B7H
	.WORD	01B8H,01B9H,01BAH,01BBH,01BCH,01BDH,01BEH,01BFH
	.WORD	01C0H,01C1H,01C2H,01C3H,01C4H,01C5H,01C6H,01C7H
	.WORD	01C8H,01C9H,01CAH,01CBH,01CCH,01CDH,01CEH,01CFH
	.WORD	01D0H,01D1H,01D2H,01D3H,01D4H,01D5H,01D6H,01D7H
	.WORD	01D8H,01D9H,01DAH,01DBH,01DCH,01DDH,01DEH,01DFH
	.WORD	01E0H,01E1H,01E2H,01E3H,01E4H,01E5H,01E6H,01E7H
	.WORD	01E8H,01E9H,01EAH,01EBH,01ECH,01EDH,01EEH,01EFH
	.WORD	01F0H,01F1H,01F2H,01F3H,01F4H,01F5H,01F6H,01F7H
	.WORD	01F8H,01F9H,01FAH,01FBH,01FCH,01FDH,01FEH,01FFH
	.WORD	0200H,0201H,0202H,0203H,0204H,0205H,0206H,0207H
	.WORD	0208H,0209H,020AH,020BH,020CH,020DH,020EH,020FH
	.WORD	0210H,0211H,0212H,0213H,0214H,0215H,0216H,0217H
	.WORD	0218H,0219H,021AH,021BH,021CH,021DH,021EH,021FH
	.WORD	0220H,0221H,0222H,0223H,0224H,0225H,0226H,0227H
	.WORD	0228H,0229H,022AH,022BH,022CH,022DH,022EH,022FH
	.WORD	0230H,0231H,0232H,0233H,0234H,0235H,0236H,0237H
	.WORD	0238H,0239H,023AH,023BH,023CH,023DH,023EH,023FH
	.WORD	0240H,0241H,0242H,0243H,0244H,0245H,0246H,0247H
	.WORD	0248H,0249H,024AH,024BH,024CH,024DH,024EH,024FH
	.WORD	0250H,0251H,0252H,0253H,0254H,0255H,0256H,0257H
	.WORD	0258H,0259H,025AH,025BH,025CH,025DH,025EH,025FH
	.WORD	0260H,0261H,0262H,0263H,0264H,0265H,0266H,0267H
	.WORD	0268H,0269H,026AH,026BH,026CH,026DH,026EH,026FH
	.WORD	0270H,0271H,0272H,0273H,0274H,0275H,0276H,0277H
	.WORD	0278H,0279H,027AH,027BH,027CH,027DH,027EH,027FH
	.WORD	0280H,0281H,0282H,0283H,0284H,0285H,0286H,0287H
	.WORD	0288H,0289H,028AH,028BH,028CH,028DH,028EH,028FH
	.WORD	0290H,0291H,0292H,0293H,0294H,0295H,0296H,0297H
	.WORD	0298H,0299H,029AH,029BH,029CH,029DH,029EH,029FH
	.WORD	02A0H,02A1H,02A2H,02A3H,02A4H,02A5H,02A6H,02A7H
	.WORD	02A8H,02A9H,02AAH,02ABH,02ACH,02ADH,02AEH,02AFH
	.WORD	02B0H,02B1H,02B2H,02B3H,02B4H,02B5H,02B6H,02B7H
	.WORD	02B8H,02B9H,02BAH,02BBH,02BCH,02BDH,02BEH,02BFH
	.WORD	02C0H,02C1H,02C2H,02C3H,02C4H,02C5H,02C6H,02C7H
	.WORD	02C8H,02C9H,02CAH,02CBH,02CCH,02CDH,02CEH,02CFH
	.WORD	02D0H,02D1H,02D2H,02D3H,02D4H,02D5H,02D6H,02D7H
	.WORD	02D8H,02D9H,02DAH,02DBH,02DCH,02DDH,02DEH,02DFH
	.WORD	02E0H,02E1H,02E2H,02E3H,02E4H,02E5H,02E6H,02E7H
	.WORD	02E8H,02E9H,02EAH,02EBH,02ECH,02EDH,02EEH,02EFH
	.WORD	02F0H,02F1H,02F2H,02F3H,02F4H,02F5H,02F6H,02F7H
	.WORD	02F8H,02F9H,02FAH,02FBH,02FCH,02FDH,02FEH,02FFH
	.WORD	0300H,0301H,0302H,0303H,0304H,0305H,0306H,0307H
	.WORD	0308H,0309H,030AH,030BH,030CH,030DH,030EH,030FH
	.WORD	0310H,0311H,0312H,0313H,0314H,0315H,0316H,0317H
	.WORD	0318H,0319H,031AH,031BH,031CH,031DH,031EH,031FH
	.WORD	0320H,0321H,0322H,0323H,0324H,0325H,0326H,0327H
	.WORD	0328H,0329H,032AH,032BH,032CH,032DH,032EH,032FH
	.WORD	0330H,0331H,0332H,0333H,0334H,0335H,0336H,0337H
	.WORD	0338H,0339H,033AH,033BH,033CH,033DH,033EH,033FH
	.WORD	0340H,0341H,0342H,0343H,0344H,0345H,0346H,0347H
	.WORD	0348H,0349H,034AH,034BH,034CH,034DH,034EH,034FH
	.WORD	0350H,0351H,0352H,0353H,0354H,0355H,0356H,0357H
	.WORD	0358H,0359H,035AH,035BH,035CH,035DH,035EH,035FH
	.WORD	0360H,0361H,0362H,0363H,0364H,0365H,0366H,0367H
	.WORD	0368H,0369H,036AH,036BH,036CH,036DH,036EH,036FH
	.WORD	0370H,0371H,0372H,0373H,0374H,0375H,0376H,0377H
	.WORD	0378H,0379H,037AH,037BH,037CH,037DH,037EH,037FH
	.WORD	0380H,0381H,0382H,0383H,0384H,0385H,0386H,0387H
	.WORD	0388H,0389H,038AH,038BH,038CH,038DH,038EH,038FH
	.WORD	0390H,0391H,0392H,0393H,0394H,0395H,0396H,0397H
	.WORD	0398H,0399H,039AH,039BH,039CH,039DH,039EH,039FH
	.WORD	03A0H,03A1H,03A2H,03A3H,03A4H,03A5H,03A6H,03A7H
	.WORD	03A8H,03A9H,03AAH,03ABH,03ACH,03ADH,03AEH,03AFH
	.WORD	03B0H,03B1H,03B2H,03B3H,03B4H,03B5H,03B6H,03B7H
	.WORD	03B8H,03B9H,03BAH,03BBH,03BCH,03BDH,03BEH,03BFH
	.WORD	03C0H,03C1H,03C2H,03C3H,03C4H,03C5H,03C6H,03C7H
	.WORD	03C8H,03C9H,03CAH,03CBH,03CCH,03CDH,03CEH,03CFH
	.WORD	03D0H,03D1H,03D2H,03D3H,03D4H,03D5H,03D6H,03D7H
	.WORD	03D8H,03D9H,03DAH,03DBH,03DCH,03DDH,03DEH,03DFH
	.WORD	03E0H,03E1H,03E2H,03E3H,03E4H,03E5H,03E6H,03E7H
	.WORD	03E8H,03E9H,03EAH,03EBH,03ECH,03EDH,03EEH,03EFH
	.WORD	03F0H,03F1H,03F2H,03F3H,03F4H,03F5H,03F6H,03F7H
	.WORD	03F8H,03F9H,03FAH,03FBH,03FCH,03FDH,03FEH,03FFH
NLINEARVELTBLX

**
** VELSUBCAR
** SUBTRACT VELS FROM ONE CAR
**
** IN
**   A0 CAR
**
** BREAKS: A1-A11,A13,A14
**
** NOT CALLED FROM INTERRUPT...
**
** JFL 18 AUG 92
** JFL 15 SEP 92; NEW VELADD
** JFL 18 SEP 92; SCRATCH A2,A3,A14,B0-B5
** JFL 28 SEP 92; NEW SCRATCH
** JFL 13 OCT 92
** JFL 14 OCT 92; ONE CAR
** JFL 04 JAN 93
**
VELSUBCAR
	
	.IF DEBUG
	MOVL	@DEBUGOBJ,A14
	CMP	A0,A14
	JRNE	VSCXXX
	NOP
VSCXXX
	.ENDIF ;DEBUG

	; A0 OBJ
	; A4 PULL VAR
	; A6 MULTIPART OBJ
	; A8
	;
	;LOAD 
	;A11 OFLAGS&OXXX1
	;A10 OYACC  
	; A9 OXVEL
	; A7 OYVEL
	; A5 OZVEL
	; A3 OXPOS
	; A2 OYPOS
	; A1 OZPOS
	;
	MOVE	A0,A4				;GET READY FOR PULL
	ADDI	OFLAGS,A4			;ADD IN PULL BASE
	MMFM	A4,A11,A10,A9,A7,A5,A3,A2,A1

	.IF SCALECARVELS
	;SCALE VELS
	MOVW	*A0(OSCALEMUL),A14
	JRZ	VSCNOVSCALE
	SETF	16,1,1			;FS1 Rs MAX BIT SIZE FOR MULTIPLIES
	SRA	8,A9			;THROW AWAY VEL RESOLUTION TO MAKE
	MPYS	A14,A9			;MULTIPLIES FASTER, ASSUME MPYSCALE==8
	;SRA	8,A7			;OYVEL
	;MPYS	A14,A7
	SRA	8,A5
	MPYS	A14,A5
	SETF	32,0,1			;RESTORE FS1
VSCNOVSCALE
	.ENDIF ;SCALECARVELS
	
	;SCROLL IF OBJECT IS STUCK TO FIXED SCREEN LOCATION
	BTST	B_NOSCROLL,A11
	JRZ	VSCDOVEL
	MOVL	@SCROLLX,A14
	SUB	A14,A9
	MOVL	@SCROLLY,A14
	SUB	A14,A7

VSCDOVEL

	;ADD VELS
	SUB	A9,A3		;X VELOCITY TO XVAL
	SUB	A7,A2		;Y VELOCITY TO YVAL
	SUB	A5,A1		;Z VELOCITY TO ZVAL

	;PUSH NEW VALS
	MMTM	A4,A3,A2,A1

	;
	;NOW DO CAR PARTS
	;
	MOVE	A0,A6
	JRUC	VSCMNEXT

VSCMULTI
	MOVE	A6,A4			;get obj base in A3 for pull of vals
	ADDI	OXVAL,A4	  	
	MMFM	A4,A3,A2,A1

	;ADD VELS
	SUB	A9,A3		;X VELOCITY TO XVAL
	SUB	A7,A2		;Y VELOCITY TO YVAL
	SUB	A5,A1		;Z VELOCITY TO ZVAL

	;PUSH NEW VALS
	MMTM	A4,A3,A2,A1

VSCMNEXT
	MOVL	*A6(OPARTS),A6
	JRNZ	VSCMULTI

VSCX
	RETS

**
** VELADD
**
** IN
**   A0 FIRST OBJ IN VLIST
** 
** JFL 14 JUL 92; FROM DREDD
** JFL 17 JUL 92
** JFL 17 AUG 92; LET Y GO NEG TO -OBJECTYMAX
** JFL 15 SEP 92; NEW VELADD
** JFL 28 SEP 92; NEW SCRATCH
** JFL 31 JAN 93; VLIST
** JFL 14 MAR 93; SCALE VELS
**
VELADD
VALOOP
	.IF DEBUG
	MOVL	*A0(OPART1),A14
	JRZ	VAXXNOPART
	CMP	A0,A14
	TLOCKON	NE ;DONT PUT PARTS ON V LIST SEPERATELY!!!
VAXXNOPART

	MOVL	@DEBUGOBJ,A14
	CMP	A0,A14
	JRNE	VAXXX
	NOP
VAXXX
	.ENDIF ;DEBUG

	; A0 CUR OBJ
	; A4 PULL REG
	; A6 MULTIPART OBJ
	; A8 SCRATCH
	;
	;LOAD 
	;A11 OFLAGS&OXXX1
	;A10 OYACC  
	; A9 OXVEL 
	; A7 OYVEL 
	; A5 OZVEL 
	; A3 OXPOS  
	; A2 OYPOS 
	; A1 OZPOS 

	;PULL STUFF
	MOVE	A0,A4				;GET READY FOR PULL
	ADDI	OFLAGS,A4			;ADD IN PULL BASE
	MMFM	A4,A11,A10,A9,A7,A5,A3,A2,A1

	.IF SCALEOBJVELS
	;SCALE VELS
	MOVW	*A0(OSCALEMUL),A14
	JRZ	VANOVSCALE
	SLL	4,A14			;SIZEOF NLINEARMULTBL
	MOVE	A14,A8			;COPY OFFSET
	ADDI	NLINEARXVELTBL,A8
	MOVW	*A8,A8			;MAPS TO BIGGER	XVEL
	ADDI	NLINEARZVELTBL,A14
	MOVW	*A14,A14		;MAPS TO SMALLER ZVEL

	SETF	16,1,1			;FS1 Rs MAX BIT SIZE FOR MULTIPLIES
	SRA	8,A9			;THROW AWAY VEL RESOLUTION TO MAKE
	MPYS	A8,A9			;OXVEL
	;SRA	8,A7   			
	;MPYS	A14,A7			;OYVEL
	;SRA	8,A10			
	;MPYS	A14,A10			;OYACC
	SRA	8,A5
	MPYS	A14,A5			;OZVEL
	SETF	32,0,1			;RESTORE FS1
VANOVSCALE
	.ENDIF ;SCALEOBJVELS

	.IF 0 ;------SCALEOBJVELS
	;SCALE VELS
	MOVW	*A0(OSCALEMUL),A14
	JRZ	VANOVSCALE
	SETF	16,1,1			;FS1 Rs MAX BIT SIZE FOR MULTIPLIES
	SRA	8,A9			;THROW AWAY VEL RESOLUTION TO MAKE
	MPYS	A14,A9			;MULTIPLIES FASTER, ASSUME MPYSCALE==8
	SRA	8,A7
	MPYS	A14,A7
	SRA	8,A5
	MPYS	A14,A5
	SETF	32,0,1			;RESTORE FS1
VANOVSCALE
	.ENDIF ;------SCALECARVELS
	
	;ADD IN SCROLL IF OBJECT IS STUCK TO FIXED SCREEN LOCATION
	BTST	B_NOSCROLL,A11
	JRZ	VAODOVEL
	MOVL	@SCROLLX,A14
	ADD	A14,A9
	MOVL	@SCROLLY,A14
	ADD	A14,A7

VAODOVEL
	;ADD VELS
	ADD	A9,A3		;ADD X VELOCITY TO XVAL
	ADD	A7,A2		;ADD Y VELOCITY TO YVAL
	ADD	A5,A1		;ADD Z VELOCITY TO ZVAL

	;FALLING?
	MOVE	A7,A7
	JRP	VAFALLING

VAFALLOK

	;PUSH NEW VALS
	MMTM	A4,A3,A2,A1

	;
	;HANDLE MULT-PARTS
	;
	MOVE	A0,A6
	JRUC	VAMULTINEXT

VAFALLING
	MOVE	A2,A2		;HIT THE GROUND YET?
	JRN	VAFALLOK	;NO

	;SETUP OYACC & OYVEL FOR REST OF ROUTINE
	SUB	A2,A7 		;FIND DISTANCE OVERSHOT FOR MULTIPARTS
	MOVE	A7,A10
	NEG	A10		;YACC + YVAL MUST ZERO OUT AT BOTTOM

	CLR	A2		;HEAD YVAL ON GROUND
	MOVL	A2,*A0(OYACC)	;ZERO YACC FOR NEXT TIME
	JRUC	VAFALLOK

VAMULTILOOP

	;PULL STUFF
	MOVE	A6,A4
	ADDI	OXVAL,A4
	MMFM	A4,A3,A2,A1
	
	;ADD VELS
	ADD	A9,A3		;ADD X VELOCITY TO XVAL
	ADD	A7,A2		;ADD Y VELOCITY TO YVAL
	ADD	A5,A1		;ADD Z VELOCITY TO ZVAL

	MMTM	A4,A3,A2,A1

VAMULTINEXT
	MOVL	*A6(OPARTS),A6	;NEXT PART
	JRNZ	VAMULTILOOP
	
	;ADJUST Y VEL FOR GRAVITY-TYPE THING
	ADD	A10,A7
	MOVL	A7,*A0(OYVEL)

VANEXT
	;DO NEXT OBJ
	MOVL	*A0(OVLINK),A0	;NEXT OBJ
	JRNZ	VALOOP

VAX
	RETS

***
*** -----------------------------------------------------------------------
***

**
** INITDMAQ
**
**  B11 ZERO WHEN DMA IS STOPPED
**  B12	NEXT DMA PUSH
**  B13 NEXT DMA PULL
**
** JFL 05 OCT 92
** JFL 24 JAN 93; DMAQPRE
**
INITDMAQ
CLRDMAQ

	GETST	A2
       	DINT

	;STOP DMA
	CLR	A14
	MOVW	A14,@DMACTRL
	MOVW	A14,@DMACTRL

	SETF	1,0,0
	MOVE	SP,@(INTENB+B_X1E),0	;X1E
	
	PUTST	A2

	;LOAD UP THE DMAQ REGISTERS
	CLR	B11
	MOVI	DMAQBOT0,B12
	MOVL	B12,@DMAQPRE0
	MOVL	B12,@DMAQPRE
	MOVL	B12,@DMAQBOT
	MOVE	B12,B13
	MOVI	DMAQBOT1,A14
	MOVL	A14,@DMAQPRE1

	MOVI	DMAQ+QSIZE,A1
	MOVL	A1,@DMAQCUR		;INIT MISC DMA QUEUE

	RETS

**
** FREEALLOBJS
**
** JFL 16 NOV 92
**
FREEALLOBJS
	MOVI	FGLISTS,A0
	CALLR	FREEDISPLAYLIST
	MOVI	PREQLIST,A0
	CALLR	FREEDISPLAYLIST
	MOVI	BGLISTS,A0
	CALLR	FREEDISPLAYLIST
	MOVI	SHADOWLIST,A0
	CALLR	FREEDISPLAYLIST
	MOVI	SCORELIST,A0
	CALLR	FREEDISPLAYLIST
	MOVI	DEBUGDMALIST,A0
	CALLR	FREEDISPLAYLIST

	RETS

**
** FREEDISPLAYLIST
**
** IN
**   A0 LIST
**
** JFL 16 NOV 92
**
FREEDISPLAYLIST
	MOVE	A0,A1
	JRZ	FDLX
FDLLOOP
	MOVL	*A0,A8
	JRZ	FDLX
	CMP	A1,A8
	JREQ	FDLX

	CALLR	ZAP_OBJ ;IN:A8
	JRUC	FDLLOOP
FDLX
	RETS

**
** 
**
** INITDISPLAYLISTS
**
** JFL 16 OCT 92
** JFL 25 JAN 93
**
INITDISPLAYLISTS

	GETST	A2
	DINT
	MOVI	FGLISTS,A14
	MOVL	A14,*A14
	MOVL	A14,*A14(OBLINK)
	MOVL	A14,*A14(OSORTLINK)

	MOVI	PREQLIST,A14
	MOVL	A14,*A14
	MOVL	A14,*A14(OBLINK)
	MOVL	A14,*A14(OSORTLINK)

	MOVI	BGLISTS,A14
	MOVL	A14,*A14
	MOVL	A14,*A14(OBLINK)
	MOVL	A14,*A14(OSORTLINK)

	MOVI	SHADOWLIST,A14
	MOVL	A14,*A14
	MOVL	A14,*A14(OBLINK)
	MOVL	A14,*A14(OSORTLINK)

	MOVI	SCORELIST,A14
	MOVL	A14,*A14
	MOVL	A14,*A14(OBLINK)
	MOVL	A14,*A14(OSORTLINK)

	MOVI	DEBUGDMALIST,A14
	MOVL	A14,*A14
	MOVL	A14,*A14(OBLINK)
	MOVL	A14,*A14(OSORTLINK)

	PUTST	A2

	RETS


**************************************************************************
BGSCROLL
	;*** UPDATE P_BASEX, P_BASEY of all bgnd planes
	;*** JUMP TO LAST PLANE IN TABLE (LAST PLANE PLOTTED, FASTEST SCROLLING)
	MOVI	BGLISTS,A0
	MOVE	@BGPLANECT,A1,W
	JRUC	SCRLPLNS

**************************************************************************
FGSCROLL
	;*** UPDATE P_BASEX, P_BASEY of all bgnd planes
	;*** JUMP TO LAST PLANE IN TABLE (LAST PLANE PLOTTED, FASTEST SCROLLING)
	MOVI	FGLISTS,A0
	MOVE	@FGPLANECT,A1,W
SCRLPLNS
	JRZ	SCROLLPLNX
	MOVE	@SCROLLY,A13,L
	MOVE	@SCROLLX,A14,L
SCROLLLP
	;*** UPDATE SCROLL POSITION OF FGND PLANE ***
	MOVE	*A0(P_XRATE),A2,L	;PLANE SCROLLX MULTIPLIER
	MPYS	A14,A2			;64 BIT MPY, RESULT -> A2:A3
	SLL	16,A2			;16.16 * 16.16 -> 32.32, WANT 16.16
	SRL	16,A3
	MOVX	A3,A2
	MOVE	*A0(P_XPOS),A3,L	;OLD SCROLLX POSITION
	ADD	A2,A3
	MOVE	A3,*A0(P_XPOS),L	;NEW ACCUMULATED SCROLLX VALUE

	MOVE	*A0(P_YRATE),A2,L	;MDP
	MPYS	A13,A2
	SLL	16,A2
	SRL	16,A3
	MOVX	A3,A2
	MOVE	*A0(P_YPOS),A3,L	;OLD SCROLLY POSITION
	ADD	A2,A3
	MOVE	A3,*A0(P_YPOS),L	;NEW ACCUMULATED SCROLLX VALUE

	ADDI	PLNSIZ,A0
	DSJS	A1,SCROLLLP
SCROLLPLNX
	RETS


**************************************************************************
;*** DEPENDS ON A LOT OF REGISTERS BEING SET UP IN DISPLAY -- careful ***

**
** SHAKEPREQ
**
** ASSUME THIS IS CALLED BEFORE ANY ITEMS BEYOND PREQ ARE ADDED TO THE Q
** ASSUME DMA HAS NOT BEEN STARTED
**
** IN
**   B1 SHAKE AMOUNT
**  B12 Q TOP
**  B13 Q BOTTOM
**
** SCRATCH:B0,B1,B2,B3,B4
**
** JFL 24 JAN 93
**
SHAKEPREQ

	MOVE	B12,B2
	MOVE	B13,B3
	JRUC	SPNEXT
SPLOOP
      	MOVL	*B3(2*20H),B4		;DAG
	SUBXY	B1,B4
      	MOVL	B4,*B3(2*20H)		;DAG
SPNEXT
	;NEXT ENTRY
	SUBI	6*20H,B3
	CMP	B2,B3
	JRHS	SPLOOP

	RETS

**
** PUTPLANES
**
** IN
**   B5 PLANE OFFSET Y:X
**
** JFL 20 JUL 92; FROM DREDD
** JFL 02 OCT 92; REDONE
** JFL 24 JAN 93
**
PUTPLANES
	;ADD IN SHAKE
	MOVL	@SHAKEXY,B0
	ADDXY	B0,B5

	;
	;SHAKE PRE QUEUED PLANE
	;

	;CHECK IF SHAKE MATCHES THAT OF PREQLIST 
	MOVW	@PAGE,A14
	JRZ	PPCHECKSHAKE0

	;GET SHAKE VALUE FOR THIS PAGE
	MOVL	@SHAKEQPRE1,B1
	SUBXY	B0,B1
	JRXNZ	PPSHAKE1
	JRYZ	PPSHAKEN
PPSHAKE1
	MOVL	B0,@SHAKEQPRE1
	CALLR	SHAKEPREQ
	JRUC	PPSHAKEN

PPCHECKSHAKE0
	;GET SHAKE VALUE FOR THIS PAGE
	MOVL	@SHAKEQPRE0,B1
	SUBXY	B0,B1
	JRXNZ	PPSHAKE0
	JRYZ	PPSHAKEN
PPSHAKE0
	MOVL	B0,@SHAKEQPRE0
	CALLR	SHAKEPREQ
	
PPSHAKEN

	;
	;START THE DMA FOR PRE QUEUED ITEMS
	;

	;START THE DMA IF WE HAVE PRE QUEUED STUFF WAITING
	DINT				;----------------------------------

	CMP	B12,B13
	JRLS	DISPDMANO

	MOVE	B11,B11
	JRNZ	DISPDMANO

	;ALLOW DMA INT
	SETF	1,0,0
	MOVE	SP,@(INTPEND+B_X1E),0
	MOVK	1,A14
	MOVE	A14,@(INTENB+B_X1E),0
	SETF	16,1,0			;RESTORE FIELD 0

	MOVI	DMAREGS,B11		;MUST LOAD THIS BEFORE KICKING DMA

	;CHECK IF DMA IS FINISHING UP LAST ITEM
	MOVW	@DMACTRL,A14
	JRN	DISPDMANO

	TRAP	1			;KICK DMA

DISPDMANO
	EINT				;----------------------------------

	;
	;OTHER PLANES
	;

	;MAKE BACKGROUND PLANE
	MOVI	BGLISTS,A0
	MOVL	*A0(P_YPOS),A1
	MOVL	*A0(P_XPOS),A2
	SRL	16,A2
	MOVX	A2,A1
	MOVL	*A0(P_XYOFF),A14
	ADDXY	A14,A1
	CALLR	MAKEBACKGROUND ;IN: A0,A1 PLANE,OFFSET Y:X

	;DISP BACKGROUND PLANE
	MOVI	BGLISTS,A0
	CALLR	DISPLAYPLANE ;IN: A0 PLANE

	;MAKE FORGROUND PLANE
	MOVI	FGLISTS,A0
	MOVL	*A0(P_YPOS),A1
	MOVL	*A0(P_XPOS),A2
	SRL	16,A2
	MOVX	A2,A1
	MOVL	*A0(P_XYOFF),A14
	ADDXY	A14,A1
	MOVE	A1,B0		;SAVE OFFSET
	CALLR	MAKEFOREGROUND ;IN: A0,A1 PLANE,OFFSET Y:X

	;MAKE SHADOWS	
	MOVI	SHADOWLIST,A0
	MOVE	B0,A1		;RESTORE OFFSET
	CALLR	MAKESHADOWS ;IN: A0,A1 PLANE,OFFSET Y:X

	;DISP SHADOW PLANE
	MOVI	SHADOWLIST,A0
	CALLR	DISPLAYPLANE ;IN: A0 PLANE

	;DISP FOREGROUND PLANE
	MOVI	FGLISTS,A0
	CALLR	DISPLAYPLANE ;IN: A0 PLANE

	.IF DEBUG
	;DISP DEBUGDMA PLANE
	MOVI	DEBUGDMALIST,A0
	CALLR	DISPLAYPLANE ;IN: A0 PLANE
	.ENDIF ;DEBUG
	
	;REMOVE SHAKE
	MOVL	@SHAKEXY,B0
	SUBXY	B0,B5

	;DISP SCORE PLANE
	.IF MAKEGHOST=0
	MOVI	SCORELIST,A0	
	CALLR	DISPLAYPLANE ;IN: A0 PLANE
	.ENDIF ;!MAKEGHOST


	RETS

**************************************************************************
* GANIOF
* GARBOF - A6=ANIOFF
* A2=H:W, A4=OFLAGS
* RETURNS
*  A6=X ANIMATION OFFSET X 64K
*  A7=Y ANIMATION OFFSET X 64K
GANIOF:
	MMTM	SP,A2,A3
	MOVE	*A1(IANIOFF),A6,L
	jruc	GotOf
GARBOF:
;A6 has offset from TL
	MMTM	SP,A2,A3
GotOf	CLR	A7		;MAKE SURE A7 IS 0
	MOVY	A6,A7
	SLL	16,A6		;MOVE TO UPPER WORD
	SUBI	00010001h,A2	;ADJUST FOR -1
	CLR	A3
	MOVY	A2,A3
	SLL	16,A2		;MOVE TO UPPER WORD
	BTST	B_FLIPH,A4
        JRZ	GANI1
	NEG	A6
	ADD	A2,A6		;SUB THS-1 FOR H-FLIP
GANI1:
	BTST	B_FLIPV,A4
	JRZ	GANI2
	NEG	A7
	ADD	A3,A7		;SUB TVS-1 FOR V-FLIP
GANI2:
	MMFM	SP,A2,A3
	RETS

QDMA
QDMANE
QDMANE_2
QDMAN
QDMAN2
	TLOCKUP	;NOT IMPLEMENTED
	RETS


**
** YZSORT
**
** IN
**   A0 PLANE
**
** JFL 28 JUL 92; FROM DREDD
** JFL 04 OCT 92; REDONE
** JFL 22 DEC 92; ONLY Z SORT
** JFL 24 JAN 93; GETST & PUTST
** JFL 25 JAN 93; SORT OZVEL ONLY
**
YZSORT
	MOVI	FGLISTS,A0
	MOVE	A0,A4

	MOVL	*A0,A0
	CMP	A0,A4
	JREQ	YZSX

	;PULL PREV Z
	;AFTER PULL: A6 Z
	MOVL	*A0(OZVAL),A6
	JRUC	YZSTHIS

YZSNOSWAP
	;MAKE THIS PREV
	MOVE	A1,A0	
	MOVE	A8,A6	

YZSTHIS
	MOVL	*A0,A1
	CMP	A1,A4
	JREQ	YZSX
	
	;PULL THIS Z
	;AFTER PULL: A8 Z
	MOVL	*A1(OZVAL),A8

	;ORDER LIST SO BIGGER ZS ARE FIRST
	;CHECK IF WE SHOULD SWAP
	CMP	A6,A8 			;CHECK Z
	JRLE	YZSNOSWAP

YZSSWAP
	GETST	A2
	DINT

	;UNLINK A0 FROM LIST
	MOVL	*A0(OBLINK),A14
	MOVL  	A1,*A14
	MOVL	A14,*A1(OBLINK)
		
	;LINK A0 AFTER A1
	MOVL  	*A1,A14
	MOVL	A14,*A0
	MOVL	A0,*A1
	MOVL	A1,*A0(OBLINK)
	MOVL  	A0,*A14(OBLINK)

	PUTST	A2

	JRUC	YZSTHIS
	
YZSX
	RETS

	.IF 0 ;DEAD
YZSORT
	MOVI	FGLISTS,A0
	MOVE	A0,A1
	JRUC	YZSNEXT
YZSLOOP
	;REG USE
	;  A0 OBJ
	;  A1 PLANE HEAD
	;  A2
	;  A3
	;  A4

	;CHECK IF THIS OBJ IS IN PROPER SPOT
	MOVL	*A0(OZVAL),A2

	;CHECK OUT FWD LINK
	MOVL	*A0,A4	
	CMP	A4,A1			;END OF LIST
	JREQ	YZSLOOKBACK
	MOVL	*A4(OZVAL),A3
	CMP	A2,A3
	JRGT	YZSFWD			;RESORT A0 FOREWARD IN PLANE

YZSLOOKBACK
	MOVL	*A0(OBLINK),A4
	CMP	A4,A1
	JREQ	YZSNEXT			;END OF LIST
	MOVL	*A4(OZVAL),A3
	CMP	A2,A3
	JRGT	YZSBWD			;RESORT A0 BACKWARD IN PLANE
	
YZSNEXT
	;NEXT
	MOVL	*A0(OSORTLINK),A0
	CMP	A0,A1
	JRNE	YZSLOOP
YZSX
	RETS

YZSPUTAFTER
	;DID WE MOVE AT ALL
	CMP	A0,A4
	JREQ	YZSNEXT
	
	GETST	A2
	DINT

	;UNLINK A0 FROM LIST
	MOVL	*A0(OBLINK),A3
	MOVL	*A0,A14
	MOVL	A14,*A3
	MOVL	A3,*A14(OBLINK)
		
	;LINK A0 AFTER A4
	MOVL  	*A4,A14
	MOVL	A14,*A0
	MOVL	A0,*A4
	MOVL	A4,*A0(OBLINK)
	MOVL  	A0,*A14(OBLINK)

	PUTST	A2
	JRUC	YZSNEXT

YZSBWD
	;RESORT A0 BACKWARD IN PLANE
	MOVL	*A4(OBLINK),A4	
	CMP	A1,A4
	JREQ	YZSPUTAFTER

	;CHECK VALUE
	MOVL	*A4(OZVAL),A3
	CMP	A2,A3
	JRGT	YZSBWD
	JRUC	YZSPUTAFTER
	
YZSFWD
	;RESORT A0 FOREWARD IN PLANE
	MOVL	*A4,A14
	CMP	A1,A14
	JREQ	YZSPUTAFTER
	
	;CHECK VALUE
	MOVL	*A14(OZVAL),A3
	CMP	A2,A3
	JRLE	YZSPUTAFTER
	MOVE	A14,A4
	JRUC	YZSFWD
	
	.ENDIF ;DEAD

**************************************************************************
* END OF DISPLAY SYSTEM
**************************************************************************



**************************************************************************
* DISPLAY UTILITY ROUTINES
**************************************************************************


**************************************************************************
* OINIT
* INITIALIZE FREE LIST, OBJ PLANES, ANIOBJS, QUEUES
OINIT
	MMTM	SP,A0,A1,A2,A3	;SAVE REG

	CALLR	INITDMAQ

	MOVI	SCRNST,A0,L	;INIT SCREEN TOP LEFT [Y,X]
	MOVE	A0,@SCRNTL,L
	MOVI	SCRNEND,A0,L	;INIT SCREEN LOWER RIGHT [Y,X]
	MOVE	A0,@SCRNLR,L

	CLR     A0
	MOVE	A0,@ANIOBJS,L
	MOVE	A0,@SCROLLX,L
	MOVE	A0,@SCROLLY,L
	MOVE	A0,@UNIVXMIN,W
	MOVE	A0,@UNIVXMAX,W
	MOVE	A0,@WORLDX,L
	MOVE	A0,@WORLDY,L
       	MOVE	A0,@WORLDXY,L
	MOVE	A0,@FGPLANECT,W
	MOVE	A0,@BGPLANECT,W

	;*** CLEAR OUT FGPLNS, BGPLNS ***
	movi	FGLISTS,A1
	movi	(BGLISTSX-FGLISTS)/010h,A2
ClrFGLp	move	A0,*A1+,W
	dsjs	A2,ClrFGLp

	;*** INITIALIZE LINK FIELDS OF PLNS ***
	movi	FGLISTS,A1
	movi	BGLISTSX,A2
InitPlns
	move	A1,*A1,L		;Make P_LSTHD point at P_LSTHD
	move	A1,*A1(020h),L		;Make P_LSTTL point at P_LSTHD
	addi	PLNSIZ,A1
	cmp	A2,A1
	jrlt	InitPlns

	;*** CLEAR OUT OBJ SPACE ***
	movi	OBJSTR,A1
	movi	OBJSTRX,A2
CLROBST	MOVW	A0,*A1+
	CMP	A2,A1
	JRLO	CLROBST

	MOVI	OBJSTR,A1,L
	MOVE	A1,@OFREE,L	;SETUP FREE LIST
  	movi	NOBJ,A3			;Init FREECNT to # of objs
	move	A3,@OFREECNT		;
oinitl:
	MOVE	A1,A2
	ADDI	OBSIZ,A1,W
	MOVE	A1,*A2,L		;LINK EM UP
	DSJS	A3,oinitl		;CONTINUE FOR NPROC
    	MOVE	A0,*A2,L		;ZERO LAST LINK
	move	A2,@ENDOFREE,L		;keep ptr to last obj on free list

	;INITIALIZE SUPPLEMENTAL LIST HEADERS
	MOVI	SUPPLSTS,A1		 ;GET THE SUPPLEMENTAL LIST AREA
	CLR	A0
OISLOOP
	MOVE	A0,*A1+,L
	CMPI	SUPPLSTSX,A1
	JRLO	OISLOOP

	MMFM	SP,A0,A1,A2,A3	;RESTORE REGS
	RETS


**************************************************************************
* CkOFREE
* WALK FREE LIST, VERIFY LENGTH AND THAT EACH OBJ'S INUSE BIT IS CLEAR
* LOCKUP ON ERROR
	.IF DEBUG
CkOFREE:
	mmtm	SP,A0,A1,A2
	PUSHST
	DINT
	clr	A1
	move	@OFREE,A0,L
	jrz	GotFreCt
CntFree	inc	A1
	movb	*A0(OCTRL+B_INUSE-7),A2
	TLOCKON	N
	MOVE	A0,A2
	move	*A0,A0,L
	jrnz	CntFree
GotFreCt:
	MOVE	@ENDOFREE,A0,L
	CMP	A0,A2
	TLOCKON	NE
	move	@OFREECNT,A0,W
	cmp	A0,A1
	TLOCKON	NE
	POPST
	mmfm	SP,A0,A1,A2
	rets
	.ENDIF


**************************************************************************
* IsAnObj
* CHECK A0 FOR BEING AN OBJECT PTR
* LOCKS UP IF BAD OBJ
IsAnObj
	PUSH	A0
	subi	OBJSTR,A0
	TLOCKON	N
	cmpi	OBJSTRX,A0
	TLOCKON	GE
	movi	OBSIZ,A14
	modu	A14,A0
	TLOCKON	NZ
	PULLQ	A0
	rets

**************************************************************************
* GETOBJ
* GET A FREE OBJECT BLOCK FOR USE
*
* RETURNS A0 = PTR TO OBJECT BLOCK
*    IF NO BLOCKS WERE AVAILABLE THEN THE Z FLAG IS SET
GETOBJ:
 	MOVL  	@OFREE,A0	; pointer to next available obj block
	JRZ	GETBADX

	.IF DEBUG
	MOVB	*A0(OCTRL+B_INUSE-7),A14
	TLOCKON	N
	.ENDIF

	;ONE LESS OBJ FREE
	move	@OFREECNT,A14,W	;dec obj free list count
	dec	A14		;
	move	A14,@OFREECNT,W	;
	jrp	SkClrEnd

	;CHECK IF THIS IS REALLY THE LAST OBJ
	.IF ASSERT
	move	@ENDOFREE,A14,L
	cmp	A14,A0
	TLOCKON	NE
	.ENDIF ;ASSERT

	clr	A14
	move	A14,@ENDOFREE,L
SkClrEnd:
	move  	*A0,A14,L
	move  	A14,@OFREE,L	; adjust pointer to free list

	;*** CLEAR OUT THE VITAL PART OF THE OBJECT BLOCK ***
	clr	A14
	movi	OCLRSIZ,B14
	srl	5,B14
	jrnc	SkObjWord
	move	A14,*A0+,W
SkObjWord
	srl	1,B14
	jrnc	SkObjLong
	move	A14,*A0+,L
SkObjLong
ObjClrLp
	move	A14,*A0+,L
	move	A14,*A0+,L
	dsjs	B14,ObjClrLp
	subi	OCLRSIZ,A0

	movi	DMAWNZ|M_INUSE,A14
	MOVW	A14,*A0(OCTRL)		;init offset:flags

	move	A0,A0		; clear Z flag
getox
	rets
GETBADX
	;PICK SOME OBJ TO RETURN
	TLOCKUP
	MOVI	OBJSTR,A0	
	RETS

**************************************************************************
*								         *
* CLRODATA - ROUTINE TO CLEAR THE ODATA AREA OF AN OBJECT.		 *
* 		A0 VERSION						 *
* A0 = PTR TO OBJECT							 *
*								         *
**************************************************************************
CLRODATA
	PUSH	A8
	MOVE	A0,A8
	CALLR	CLR_ODATA
	PULLQ	A8
	RETS

**************************************************************************
*								         *
* CLR_ODATA - ROUTINE TO CLEAR THE ODATA AREA OF AN OBJECT		 *
* A8 = PTR TO OBJECT							 *
*								         *
**************************************************************************
CLR_ODATA
	MMTM	SP,A1,A2
	MOVE	A8,A1
	MOVE	A1,A2
	ADDI	ODATA,A1
	ADDI	ODATAX,A2
	CALLA	CLRBLOCK
	MMFM	SP,A1,A2
	RETS


***
*** OBJECTS -------------------------------------------------------------
***

**
** NOTE:
** BECAUSE THE DISPLAY INTERRUPT FOLLOWS THESE LINKAGES
** MAKE SURE TO DINT WHEN PLAYING WITH THEM: OLINK,OBLINK,OVLINK
** 

**************************************************************************
*								         *
* INSERT_OBJ - If head of multi-parter, entire multi-parter inserted.	 *
* 	     If sub-part of multi-parter, just sub-part inserted.	 *
* 	     OID is checked to insert object on supplemental list.	 *
* A8 = OBJ								 *
* RETURNS								 *
* 	nothing								 *
*								         *
**************************************************************************
INSERT_OBJ:
	PUSH	A0
	move	*A8(OPART1),A0,L
	jrz	SkInsMulti
	cmp	A0,A8			;Is Part Head Obj
	jrne	SkInsMulti

InsMulti
;* TO INSERT A HEAD OBJECT, INSERT SUBPARTS FIRST
;* THIS COULD BE MADE MORE EFFICIENT BY INSERTING ENTIRE MULTI-PARTER
;* TOGETHER INSTEAD OF CALLING INSOBJ FOR EACH PIECE
	move	*A0(OPARTS),A0,L
	jrz	SkInsMulti
	callr	INSOBJ ;IN:A0			;INSERT Sub-Part
	jruc	InsMulti
SkInsMulti
	move	A8,A0
	callr	INSOBJ ;IN:A0
	PULLQ	A0
	rets


**************************************************************************
*								         *
* INSBOBJ - INSERT AN OBJECT ON THE BACKGROUND LIST.			 *
* A0 = PTR TO OBJECT							 *
* *A0(OPLANE) = PLANE NUMBER TO INSERT UPON				 *
*								         *
**************************************************************************
INSBOBJ:
	mmtm 	SP,A1,A2,A3,A4,A5

	movi	BGLISTS,A3

	jruc	INSGOTPLN


****************************************************************************
* INSPLANE
* Inserts obj on a bgnd plane
* does not set OPLANE..
*
* A0 = OBJ to insert
* B0 = ptr to plane
* RETURNS nothing
INSPLANE:
	mmtm 	SP,A1,A2,A3,A4,A5
	move	B0,A3
	jruc	INSGOTPLN

**
** INSOBJ
** Insert obj into doubly linked object list
** List is sorted by increasing Z and increasing Y within constant Z
** If M_NOAUTOZ set in OFLAGS use A1 as plane # (0 = closest plane)
** If M_NOSCROLL set in OFLAGS use plane 0
**   Else automatically determine plane based on Z coor
** OID is checked to insert object on supplemental list
**
** IN
**   A0 OBJ
**
** JFL 24 JAN 93; GETST & PUTST
** JFL 31 JAN 93; INSVLIST, RE-WRITE
**
INSOBJ
	MMTM 	SP,A1,A2,A3,A4,A5

	MOVI	FGLISTS,A3
INSGOTPLN

	.IF DEBUG
	;IS OBJ ALREADY INSERTED?
	MOVL	*A0,A4
	TLOCKON	NZ
	callr	IsAnObj
	.ENDIF ;DEBUG

	MOVE	A3,A4
	MOVL 	*A0(OZVAL),A1		; GET Z POSITION
	
INSLOOP
	;NEXT OBJ
	MOVL	*A3,A3	      
	CMP	A3,A4
	JREQ	INSDO

	;CHECK Z OF THIS OBJ
	MOVL	*A3(OZVAL),A2
	CMP	A2,A1
	JRLT	INSLOOP
INSDO
	;LINK IN BEFORE OBJ
	MOVL 	*A3(OBLINK),A2		;PREV
	GETST	A4
	DINT
	MOVL	A3,*A0
	MOVL	A0,*A2
	MOVL	A0,*A3(OBLINK)
	MOVL	A2,*A0(OBLINK)
	PUTST	A4

	CALLR	INSSUPP			;INSERT ON SUPPLEMENTAL LIST
	MOVB	*A0(OID+B_OIDFAUTOVEL-7),A14
	JRNN	INSOBJX
	CALLR	INSVLIST ;IN:A0,A2-A3 OBJ,SC

INSOBJX
	MMFM 	SP,A1,A2,A3,A4,A5
	RETS


**************************************************************************
* PULL_OBJ
* PULLS OBJECT FROM A DOUBLY LINKED OBJECT LIST
* MULTI-PART PIECES ARE NOT UNLINKED
* IF HEAD OF MULTI-PARTER, ENTIRE MULTI-PARTER PULLED
* IF SUB-PART OF MULTI-PARTER, JUST SUB-PART PULLED
* OID IS CHECKED TO PULL OBJECT FROM SUPPLEMENTAL LIST
*
* A8 = OBJ to be pulled
* RETS nothing
PULL_OBJ:
	PUSH	A0
	move	*A8(OPART1),A0,L
	jrz	SkPullMulti
	cmp	A0,A8			;Is Part Head Obj
	jrne	SkPullMulti

PullMulti ;* TO PULL A HEAD OBJECT, PULL ANY SUBPARTS FIRST
	move	*A0(OPARTS),A0,L
	jrz	SkPullMulti
	callr	PULLOBJ			;Pull Sub-Part
	jruc	PullMulti
SkPullMulti
	move	A8,A0
	callr	PULLOBJ
	PULLQ	A0
	rets

**************************************************************************
* PULLOBJ
* PULLS OBJECT FROM A DOUBLY LINKED OBJECT LIST
* IF OBJ NOT INSERTED, DOES NOTHING
* OID IS CHECKED TO PULL OBJECT FROM SUPPLEMENTAL LIST
* SHADOW OBJ IS PULLED
* OLINK CLEARED TO MARK OBJ AS NOT BEING INSERTED
*
* A0 = OBJ to be pulled
* RETS nothing
**
** JFL 24 JAN 93; GETST & PUTST
** JFL 31 JAN 93
** JFL 14 MAR 93
**
PULLOBJ
	CALLR	PULLSHAD	;PULL SHADOW
	CALLR	PULLSUPP	;PULL FROM SUPPLEMENTAL LIST

	MOVL	*A0(OGCOL),A14
	JRZ	PONOGC
  	CALLR	PULLGCOLLNC	;PULL FROM GROUND COLLISION LIST
PONOGC

	;
	;PULL FROM VLIST
	;

	;TEST FLAG TO SEE IF THIS IS IN VLIST
	MOVB	*A0(OID+B_OIDFAUTOVEL-7),A14
	JRNN	JUSTPULLOBJ

	CALLR	PULLVLIST ;IN:A0 OBJ

JUSTPULLOBJ
	move	*A0(OLINK),A14,L	;IS OBJ INSERTED?
	jrz	SkPULLOBJ

	MMTM	SP,A1,A2
	GETST	A2
	DINT
	MOVL	*A0(OBLINK),A1		;A1 - Prev Obj
	MOVL	*A0,A14			;A14 - Next Obj
	MOVL	A14,*A1			;LINK FORWARD AROUND OBJ A0
	MOVL	A1,*A14(OBLINK)		;LINK BACKWARD AROUND OBJ A0
	CLR	A14
	MOVL	A14,*A0(OLINK)		;OBJ NOT INSERTED
	PUTST	A2
	MMFM	SP,A1,A2

SkPULLOBJ
	rets


**
** ZAP_OBJ
** FREE_OBJ
** DELETE_OBJ
**
** IN
**   A8 OBJ
**
** ZAP_OBJ: - ENTRY POINT IF PLINK SHOULD NOT BE CHECKED
** IF OPLINK SET, IT MUST POINT TO CURRENT PROCESS
** PUTS OBJ ON END OF FREE LIST
** IF HEAD OF MULTI-PARTER, ENTIRE MULTI-PARTER FREED (NOT DISASSEMBLED)
** IF SUB-PART OF MULTI-PARTER, SUB-PART UNLINKED AND FREED
** IF PART ON OBJ LIST, OBJ PULLED DOUBLY LINKED OBJECT LIST
** IF PART ON ANIM, IT IS PULLED
** IF PART HAS SHADOW, SHADOW FREED
** PALETTE IS DEALLOCATED
**
** JFL 15 FEB 93
** JFL 19 FEB 93
**
DELETE_OBJ
FREE_OBJ
ZAP_OBJ
	PUSH	A0
	MOVL	*A8(OPART1),A0
	JRZ	ZOFREEONE
	CMP	A0,A8
	JREQ	ZOFREEMULTI		;MULTIPART HEAD... FREE WHOLE THING

	;
	;UNLINK THE PART FROM THE HEAD OBJ
	;
	CALLR	PULLPART ;IN:A0,A8 OPART1,OBJ
	JRUC	ZOFREEONE
ZOFREEMULTI
	;
	;FREE ALL PARTS OF A MULTIPARTER
	;
	MOVL	*A0(OPARTS),A0
	JRZ	ZOFREEONE
	CALLR	ZAPOBJ ;IN:A0
	JRUC	ZOFREEMULTI
ZOFREEONE
	;
	;FREE ONE OBJECT
	;
	MOVE	A8,A0
	CALLR	ZAPOBJ ;IN:A0 OBJ
	PULLQ	A0
	RETS

**
** PULLPART
**
** IN
**   A0 OPART1 OF A8, SCRATCH
**   A8 PART OF MULTIPARTER TO UNLINK
**
** JFL 15 FEB 93
**
PULLPART
	MOVE	A0,A14
PPLOOP
	MOVE	A14,A0
	MOVL	*A0(OPARTS),A14
	JRZ	PPX
	CMP	A14,A8
	JRNE	PPLOOP

	;GETST	A14
	;DINT

	;UNLINK
	MOVL	*A8(OPARTS),*A0(OPARTS)

	;PUTST	A14

PPX
	RETS

**
** ZAPOBJ
** DELOBJ
** FREEOBJ
** DOFREE
**
** IF OPLINK SET, IT MUST POINT TO CURRENT PROCESS
** OID IS CHECKED TO PULL OBJECT FROM SUPPLEMENTAL LIST
** PUTS OBJ ON END OF FREE LIST
** INUSE BIT CLEARED
** FREEGOBJ (free garbage obj) Skips the following checks
**   IF PART ON AN OBJLST, IT IS PULLED
**   IF PART WAS ON ANIM, IT IS PULLED
**   SHADOW OBJ IS FREED
**   PALETTE IS DEALLOCATED
** ERRORS if obj not valid ptr, obj is already free
**
** IN
**   A0 OBJ to be deleted/freed
**
** JFL 21 FEB 93
**
DELOBJ
FREEOBJ
	.IF DEBUG
	MOVL	*A0(OPLINK),A14
	JRZ	ZAPOBJ
	CMP	A14,A13
	TLOCKON	NE ;NOT PROPER PROCESS
	.ENDIF
ZAPOBJ
	.IF DEBUG
	CALLR	IsAnObj
	.ENDIF ;DEBUG

	;CHECK IF ITS INSERTED
	MOVL	*A0,A14
	JRZ	ZOX	;ZAPPING A NON-INSERTED OBJ (THIS DOES HAPPEN)

	;CLEAR INUSE BIT TO MARK OBJ AS ON FREE LIST
	SETF	1,0,0
	MOVE	SP,*A0(OCTRL+B_INUSE),0
	SETF	16,1,0

	MOVB	*A0(OFLAGS+B_ANIM-7),A14
	JRNN	ZONOANI
	CALLR	PULLANIM ;IN:A0
ZONOANI
	CALLR	PULLOBJ	;PULLS SHADOW TOO
	;CALLA	DELPAL

DOFREE
	;PUT OBJ ON FREE LIST
	MOVW	@OFREECNT,A14
	INC	A14
	MOVW	A14,@OFREECNT
	MOVL	@ENDOFREE,A14
	JRZ	ZONOFREE

	;LINK INTO LAST FREE OBJ
	MOVL	A0,*A14
	JRUC	ZOATEND
ZONOFREE
	;SET START OF FREE LIST TO THIS OBJ
	MOVL	A0,@OFREE
ZOATEND
	;SET END OF FREE LIST TO THIS OBJ
	MOVL	A0,@ENDOFREE
ZOX
	RETS

**************************************************************************
* DELSHAD
* DELETES THE SHADOW OBJ ASSOCIATED WITH A GIVEN OBJ
*
* A0 = PTR TO OBJECT THAT CREATED THE SHADOW
* RETURNS nothing
*
* JFL 02 OCT 92
*
PULLSHAD
DELSHAD
	MOVL	*A0(OSHAD),A14
	JRZ	DELSHADX 		;BR = NO SHADOW EXISTS

	PUSH	A1

	.IF ASSERT
	MOVL	*A14(OSHAD),A1
	CMP	A1,A0
	TLOCKON	NE ;MUST BELONG TO OBJ
	.ENDIF ;ASSERT

	MOVE	A0,A1		;SAVE

	;PULL SHADOW OBJ
	MOVE	A14,A0
	CALLR	JUSTPULLOBJ ;IN: A0 OBJ

	;FREE SHADOW OBJ
	SETF	1,0,0
	MOVE	SP,*A0(OCTRL+B_INUSE),0
	SETF	16,1,0

	CALLR	DOFREE	

	MOVE	A1,A0		;RESTORE

	;NO MORE SHADOW
	CLR	A1
	MOVL	A1,*A0(OSHAD)

	PULL	A1
DELSHADX
	RETS


**************************************************************************
*								         *
* FPSTFOBJ0								 *
* FIND PAL AND THEN..							 *
* STFOBJ0								 *
* INIT OBJ W/ STARTING FRAME						 *
* A0 = PTR TO THE OBJ							 *
* A1 = PTR TO 1st Frame							 *
* 									 *
* 	  Z = FAILURE IN SOME WAY OR ANOTHER.				 *
*        NZ = SUCCESS							 *
*								         *
* JFL 13 SEP 92; SCALE FIX
*
**************************************************************************
FPSTFOBJ0:
	PUSH	A2
	MOVE	A0,A2
	MOVL	*A1(ICMAP),A0
	CALLA	GETFPAL
	
	.IF ASSERT
	JRNZ	STFOBJ_PAL		;BR = WE HAVE PALETTE!
	MOVE	A2,A0			;ERROR CONDITION, RESTORE OBJECT
	SETZ				;Z TO FLAG ERROR
	JRUC	STFOBJX			;RETURN
STFOBJ_PAL
	.ENDIF ;ASSERT

	move	A0,*A2(OPAL),W
	move	A2,A0
	jruc	STFOBJE
STFOBJ0
	PUSH	A2
STFOBJE
	move	A1,*A0(OIMG),L
	move	*a0(OIHOFF),a14	; WBDNEW
	add	a14,a1		; WBDNEW
	move	*A1,A14,L	;ISIZE (offset 0)
	move	A14,*A0(OSIZE),L
	MOVE	A14,*A0(OUSIZE),L
	move	*A1(ISAG),*A0(OSAG),L
	MOVE	*A1(ICTRL),*A0(OCTRL),W

	MOVE	*A1(IANIOFF),A14,L
	MOVE	A14,*A0(OANIOFF),L
	move	A14,*A0(OUANIOFF),L

	MOVE	A0,A0
STFOBJX
	PULL	A2
	RETS


**
** INSANI - errors if already on
** CKINSANI - only inserts if not already on
** A0 = OBJ to be Animated/Flown by ANIMP
**
** ***NOTE***
** the following obj fields must be appropriately initialized before insertion.
** ANIMSCR 	-PTR TO LONGNULL TERMINATED ANIMATION SCRIPT W/ FORMAT OF
**  .long frame ;if Bit 0 of frame ptr = '1' don't animate..
**  .word AFUNC_FLAG.1:SleepTime.15
**
**  IF AFUNC_FLAG IS SET THEN THIS LONG FOLLOWS
**  [.long Function|# of ARG words (0-15)] if FuncFlag set
**	!!!!! WARNING WARNING WARNING WARNING WARNING WARNING !!!!!
**	!!!!! 						      !!!!!
**	!!!!! The low four bits of the animation function     !!!!!
**	!!!!! Address are used to indicate the number of      !!!!!
**	!!!!! WORD arguments used by this function.	      !!!!!
**	!!!!! ALWAYS use GETAFARG_xxxx to grab arguments.     !!!!!
**	!!!!! 						      !!!!!
**	!!!!! WARNING WARNING WARNING WARNING WARNING WARNING !!!!!
** ANIMFRM	-PTR TO CURRENT ENTRY IN ANIMATION SCRIPT
** ANIMSLPB	-WORD, # TIKS 0..127 BEFORE NEXT ANI
** ANIMSLPA 	-WORD, OVERLAYED ON ANIMSCR, RESETS ANIMSLPA WHEN SLEEPTIME=0
** ANIMARG	-SET BY ANIMP, USED BY GETAFARG_XXXX
**
** JFL 24 JAN 93; GETST & PUTST
** JFL 09 FEB 93
** JFL 22 FEB 93; NO DINT
**
CKINSANI
	;*** ONLY INSERT OBJ IF IT ISN'T ALREADY ON ***
	MOVB	*A0(OFLAGS+B_ANIM-7),A14
	JRNN	INSANI
	RETS
INSANI
	.IF	DEBUG
	callr	IsAnObj
	callr	OnAnim
	.ENDIF

	;**** MARK OBJ AS BEING ON ANIM LIST ****
	SETF	1,0,0
	MOVK	1,A14
	MOVE	A14,*A0(OFLAGS+B_ANIM),0
	SETF	16,1,0

	;LINK OBJ INTO HEAD OF ANIOBJS LIST
	MOVL	@ANIOBJS,A14
	MOVL	A14,*A0(ANIMNXT)
	MOVL	A0,@ANIOBJS

	RETS

**
** PULLANIMFUNC
**
** IN
**   A0 OBJ TO PULL
**  A12 IF IN_ANIM MUST POINT TO ANIM FUNC QUEUE
**
** JFL 21 FEB 93
**
PULLANIMFUNC
	.IF DEBUG
	;MUST BE IN_ANIM 
	MOVW	@IN_ANIM,A14
	TLOCKON	Z ;CHECK BEFORE CALLING!
	JRZ	PAFX
	.ENDIF ;DEBUG

	MMTM	SP,A1,A12

	.IF DEBUG
	;MAKE SURE NO ONE HAS FUCKED WITH A12
	CMPI	ANIFUNCS,A12
	TLOCKON	LO
	CMPI	ANIFUNCSX,A12
	TLOCKON	HS
	.ENDIF

	;SCAN REST OF ANIM FUNC QUEUE FOR FUNC WITH THIS OBJ.
PAFLOOP
	MOVL	*A12+,A14	;another func?
	JRZ	PAFNOX
	MOVL	*A12+,A14	;check the obj to match A0
	CMP	A0,A14
	JRNE	PAFLOOP

	;*** WE HAVE A QUEUED UP ANIM FUNC FOR THIS OBJ, PULL IT ***
	;*** Pull by shifting other funcs up queue ***
PAFSHIFT
	MOVE	A12,A14		;A12 src, A14 dest
	SUBI	040H,A14
	MOVL	*A12+,A1	;FUNC, set the ZFLAG
	MOVL	A1,*A14+
	MOVL	*A12+,*A14+	;OBJ
	MOVE	A1,A1
	JRNZ	PAFSHIFT
	
PAFNOX
	MMFM	SP,A1,A12
PAFX
	RETS

**
** CKPULLANIM
** PULLANIM
**
** IN
**   A0 OBJ to be pulled from ANIOBJS
** A12 if IN_ANIM, A12 must be pointing to ANIM FUNC QUEUE
**
** JFL 24 SEP 92
** JFL 21 FEB 93
**
CKPULLANIM	;PULL FROM ANIM IF NECESSARY
	MOVB	*A0(OFLAGS+B_ANIM-7),A14
	JRNN	PAX
PULLANIM
	PUSH	A2

	;MARK OBJ AS BEING OFF ANIM LIST ****
	SETF	1,0,0
	MOVE	SP,*A0(OFLAGS+B_ANIM),0
	SETF	16,1,0

	;CHECK IF WE NEED TO WORRY ABOUT THE ANIM FUNC
	MOVW	@IN_ANIM,A14
	JRZ	PANOFUN
	CALLA	PULLANIMFUNC	;stop any queued anim func
PANOFUN

	;CHECK IF ITS THE FIRST OBJ
	MOVL	@ANIOBJS,A14
	CMP	A0,A14
	JRNE	PALOOP

	;PULL FIRST OBJ
	MOVL	*A0(ANIMNXT),A14
	MOVL	A14,@ANIOBJS
	JRUC	PANOX

PALOOP
	MOVE 	A14,A2			;PTR TO PREVIOUS IN A2
	MOVL 	*A2(ANIMNXT),A14	;PTR TO NEXT IN A14
	CMP  	A14,A0			;IS THIS THE GUY?
	JRNE 	PALOOP

	;LINK AROUND
	MOVL 	*A0(ANIMNXT),*A2(ANIMNXT)
PANOX

	PULLQ	A2
PAX
	RETS

**************************************************************************
* OnAnim
* hang if A0 is on ANIOBJS LIST
	.IF DEBUG
OnAnim:
	move	@ANIOBJS,A14,L
	jrz	AniOnLpX
AniOnLp:
	cmp	A0,A14
	LOCKON	EQ
	MOVE	*A14(ANIMNXT),A14,L
	jrnz	AniOnLp
AniOnLpX:
	rets
	.ENDIF


**************************************************************************
*								         *
* CREATE_OBJ - CREATE AN OBJECT AND STUFF IT, LEAVE IT UNINSERTED.	 *
* 		USES THE "NEW" (11/15/90) INITIALIZATION TABLE.		 *
* A5 = PTR TO INIT TABLE						 *
* RETURNS								 *
* 	 Z = FAILURE TO CREATE EITHER OBJECT OR PALETTE.		 *
* 		A0 = 0							 *
* 	NZ = O.K.							 *
* 		A0 = POINTER TO OBJECT					 *
* 		A5 = NEXT WORD AFTER INITIALIZATION			 *
*								         *
**************************************************************************
CREATE_OBJ
	CALLR	GETOBJ
	JRZ	CO_X			;OBJECT BLOCK FAILURE
	CALLR	INIT_OBJ
	JRNZ	CO_X
	CALLR	FREEOBJ			;DO THIS ON MASTER PALETTE FAILURE
	CLR	A0			;SET THE Z FLAG
CO_X:
	RETS
;WFD
**************************************************************************
*								         *
* INIT_OBJ - INITIALIZE AN OBJECT BLOCK USING AN INITIALIZATION TABLE.	 *
* A0 = OBJECT BLOCK TO INITIALIZE					 *
* A5 = PTR TO "NEW" INITIALIZATION TABLE				 *
* A8 - A11 = MUST BE PASSED TO CREATE FUNC IF CALLED.			 *
* RETURNS:								 *
* 	 Z = PALETTE ALLOCATE FAILURE, OBJECT NOT STUFFED		 *
* 	NZ = ALL IS WELL						 *
* A5 = POINTING TO NEXT WORD AFTER INITIALIZATION TABLE			 *
* 									 *
* 		 INITIALIZATION TABLE -- STRUCT DEF AS COXXXX IN APEQU	 *
* 		 --------------------					 *
* 	.LONG	OIMG,OCVECT						 *
* 	.WORD	OID,OCTRL,OFLAGS
*	.WORD	OSCALETYPE
* 	.LONG	CFUNC							 *
*								         *
**************************************************************************
**
** JFL 30 OCT 92
**
INIT_OBJ
	PUSH	A1
	MMTM	SP,B0,B1,B2,B3

	MOVE	*A5+,A1,L
	CALLR	FPSTFOBJ0
	JRZ	IO_X

	MOVE	A5,B0
	move	A0,B1
	move	*B0+,B2,L		;Load OCVECT
	move	B2,*B1(OCVECT),L
	move	*B0+,B2,W		;Load OID
	move	B2,*B1(OID),W
	move	*B0+,B2,W		;Load OCTRL

	MOVE	*B1(OCTRL),B3,W
	OR	B2,B3
	move	B3,*B1(OCTRL),W
IO_FLAGSOK
	MOVE	*B0+,B2,W		;Load OFLAGS
	MOVE	B2,*B1(OFLAGS),W
	MOVW	*B0+,B2			;Load OSCALETYPE
	MOVW	B2,*B1(OSCALETYPE)

	MOVE	*B0+,B2,L		;GET THE CFUNC
	JRZ	IO_NOCFUNC
	CALL	B2			;CALL IT
IO_NOCFUNC
	MOVE	B0,A5
IO_X
	MMFM	SP,B0,B1,B2,B3
	PULL	A1
	RETS

**************************************************************************
* GET_SUPP
* Returns ptr to supplemental list header
*
* A8 = obj
* RETURNS A0 = supp list header - OSLINK (Z set if not on any list)
GET_SUPP:
	move	A8,A0
	callr	GETSUPP
	move	A14,A0
	rets

**************************************************************************
* GETSUPP
* Returns ptr to supplemental list header
*
* A0 = obj
* RETURNS A14 = supp list header - OSLINK (Z set if not on any list)
*
* JFL 29 OCT 92; USE SHIFT LEFT FIRST
*
GETSUPP
	MOVW	*A0(OID),A14
	SLL	SL_SUPL,A14
	SRL	SR_SUPL,A14
	JRZ	NoSupp
	SLL	5,A14		;SIZEOF SUPPLSTS
	ADDI	SUPPLSTS-OSLINK,A14
NoSupp
	RETS

**
** INSSUPP
** Inserts object onto a supplemental list
** List is selected by the SUPP field of the OID
**
** IN
**   A0 OBJ to insert
**
** JFL 22 FEB 93
**
INSSUPP
	;GET SUPL
	MOVW	*A0(OID),A14
	SLL	SL_SUPL,A14
	SRL	SR_SUPL,A14
	JRZ	ISX
	SLL	5,A14		;SIZEOF SUPPLSTS
	ADDI	SUPPLSTS-OSLINK,A14

	.IF DEBUG
	;CHECK IF OBJECT IS ALREADY ON SUPPLEMENTAL LIST ******
	MOVE	A14,B14		;SAVE
	
ISCHECK
	CMP	A14,A0
	TLOCKON	EQ ;ALREADY ON SUPL
	MOVL	*A14(OSLINK),A14
	JRNZ	ISCHECK
	MOVE	B14,A14		;UNSAVE
	.ENDIF ;DEBUG

	;LINK IN
	MOVL	*A14(OSLINK),*A0(OSLINK)
	MOVL	A0,*A14(OSLINK)
ISX
	RETS

**
** INSSORT
**
** IN
**   A0 OBJ
**   A3 PLANE
**
** JFL 25 JAN 93 -- DEFUNCT
**
INSSORT
	MOVB	*A0(OFLAGS+B_NOTFG-7),A14
	JRN	ISRX

	;INSERT
	MOVL	*A3(P_SORT),*A0(OSORTLINK)
	MOVL	A0,*A3(P_SORT)

ISRX
	RETS

**
** INSVLIST
**
** IN
**   A0 OBJ
**   A2-A3 SCRATCH
**
** JFL 31 JAN 93
** JFL 22 FEB 93; DINT
**
INSVLIST

	.IF DEBUG
	MOVL	@AUTOVELLIST,A14
	JRZ	IVLDEBUGX
IVLDEBUG
	CMP	A14,A0
	TLOCKON	EQ
	MOVL	*A14(OVLINK),A14
	JRNZ	IVLDEBUG
IVLDEBUGX
	.ENDIF ;DEBUG

	GETST	A2
	DINT
	MOVL	@AUTOVELLIST,A14
	MOVL	A14,*A0(OVLINK)
	MOVL	A0,@AUTOVELLIST
	PUTST	A2
	RETS

**
** PULLVLIST
**
** IN
**   A0 OBJ
**
** JFL 22 JAN 93
** JFL 31 JAN 93; FROM PULLGCOLL
**
PULLVLIST

	MMTM	SP,A1
	GETST	B14
	DINT

	.IF DEBUG
	MOVB	*A0(OID+B_OIDFAUTOVEL-7),A14
	TLOCKON	NN
	.ENDIF ;DEBUG

	;GET FIRST IN LIST & CHECK IF ITS A MATCH
	MOVL	@AUTOVELLIST,A1
	TLOCKON	Z
	CMP	A0,A1
	JRNE	PVLLOOP

	;UNLINK FIRST IN LIST
	MOVL	*A0(OVLINK),A14
	MOVL	A14,@AUTOVELLIST
	JRUC	PVLPULLEDX

PVLLOOP
	;CHECK NEXT IN LIST
	MOVE	A1,A14
	MOVL	*A1(OVLINK),A1
	TLOCKON	Z
	JRZ	PVLX
	CMP	A0,A1
	JRNE	PVLLOOP
	
	;UNLINK
	MOVL	*A0(OVLINK),*A14(OVLINK)

PVLPULLEDX
	SETF	1,0,0
	MOVE	SP,*A0(OID+B_OIDFAUTOVEL),0
	SETF	16,1,0
	;CLR	A14
	;MOVL	A14,*A0(OVLINK)
PVLX
	PUTST	B14
	MMFM	SP,A1
	RETS

**
** PULLSORT
**
** IN
**   A0 OBJ
**
** JFL 25 JAN 93 -- DEFUNCT
**
PULLSORT
	MOVL	*A0(OSORTLINK),A14
	JRZ	PSR2X

	MMTM	SP,A1
		
PSRLOOP
	MOVE	A14,A1
	MOVL	*A14(OSORTLINK),A14
	CMP	A14,A0
	JRNZ	PSRLOOP

	;UNLINK
	MOVL	*A0(OSORTLINK),*A1(OSORTLINK)
	CLR	A14
	MOVL	A14,*A0(OSORTLINK)

PSRX
	MMFM	SP,A1
PSR2X
	RETS

**
** PULLGCOLL
** PULLGCOLLNC -- NO CHECK
**
** IN
**   A0 OBJ
**
** JFL 22 JAN 93
** JFL 04 FEB 93; FIXED
**
PULLGCOLL
	MOVL	*A0(OGCOL),A14
	JRZ	PGCNOTX
PULLGCOLLNC
	PUSH	A1

	;GET FIRST IN LIST & CHECK IF ITS A MATCH
	MOVL	@GCOLLIST,A1
	CMP	A0,A1
	JRNE	PGCLOOP

	;UNLINK FIRST IN LIST
	MOVL	*A0(OGCOLLINK),A14
	MOVL	A14,@GCOLLIST
	JRUC	PGCPULLEDX

PGCLOOP
	;CHECK NEXT IN LIST
	MOVE	A1,A14
	MOVL	*A1(OGCOLLINK),A1
	JRZ	PGCX
	CMP	A0,A1
	JRNE	PGCLOOP
	
	;UNLINK
	MOVL	*A0(OGCOLLINK),*A14(OGCOLLINK)
PGCPULLEDX
	CLR	A14
	MOVL	A14,*A0(OGCOL)
PGCX
	PULLQ	A1
PGCNOTX
	RETS

**
** PULLSUPP
** pulls object from a supplemental list
** List is selected by the SUPP field of the OID
**
** A0 = OBJ to pull
** RETURNS nothing
**
PULLSUPP
	PUSH	A1
	CALLR	GETSUPP
	JRZ	SKPULLSUPP

PSLOOP
	MOVE	A14,A1
	MOVL	*A14(OSLINK),A14
	TLOCKON	Z ;NOT ON SUPL
	JRZ	SKPULLSUPP
	CMP	A14,A0
	JRNE	PSLOOP

	MOVL	*A0(OSLINK),*A1(OSLINK)
	CLR	A1
	MOVL	A1,*A0(OSLINK)
SKPULLSUPP
	PULLQ	A1
	RETS

**************************************************************************
* CNTSUPP
* COUNT THE NUMBER OF OBJECTS ON GIVEN SUPPLEMENTAL LIST.
*
* A14 = SUPPLEMENTAL LIST HEADER - OSLINK
* RETURNS A0 = OBJECT CNT (SETS THE Z BIT)
*         A14 = TRASHED
CNTSUPP:
	clr	A0
CntSupLp
	move	*A14(OSLINK),A14,L
	jrz	CNTSUPPX
	inc	A0
	cmpi	NOBJ,A0
	jruc	CntSupLp
CNTSUPPX
	move	A0,A0
	rets


**************************************************************************
*                                                                        *
* OBJ_OFF - TURN AN OBJECT "OFF" I.E. SET DMA OUTPUT = 0		 *
* A8 = PTR TO OBJECT BLOCK						 *
*                                                                        *
**************************************************************************
OBJ_OFF:
	MOVE	*A8(OCTRL),A14,W
;WFD	MOVE	*A8(OFLAGS),A14,W
	SRL	4,A14
	SLL	4,A14
	MOVE	A14,*A8(OCTRL),W
;WFD	MOVE	A14,*A8(OFLAGS),W
	RETS


**************************************************************************
*                                                                        *
* SCREXP32 - SHRINK OR EXPAND THE SCREEN WINDOW FROM THE CURRENT SIZE	 *
*	      TO THE GIVEN IN A GIVEN AMOUNT OF TICKS			 *
* A0 = # OF TICKS							 *
* A10 = NEW SCRNTL							 *
* A11 = NEW SCRNLR							 *
* NOTE: CALL WITH JSRP							 *
*	TRASHES A8 & A9							 *
*                                                                        *
**************************************************************************
SCREXP32
	MOVE	@SCRNTL,A14,L
	MOVX	A14,A1
	SLL	16,A1
	CLR	A2
	MOVY	A14,A2
	SUBXY	A10,A14
	MOVX	A14,A5
	SLL	16,A5
	DIVS	A0,A5
	NEG	A5
	MOVE	A5,A6
	CLR	A5
	MOVY	A14,A5
	DIVS	A0,A5
	NEG	A5
	MOVE	A5,A7

	MOVE	@SCRNLR,A14,L
	MOVX	A14,A3
	SLL	16,A3
	CLR	A4
	MOVY	A14,A4
	SUBXY	A11,A14
	MOVX	A14,A5
	SLL	16,A5
	DIVS	A0,A5
	NEG	A5
	MOVE	A5,A8
	CLR	A5
	MOVY	A14,A5
	DIVS	A0,A5
	NEG	A5
	MOVE	A5,A9
	MOVE	A0,A5
SHTIMLP
	ADD	A6,A1			;ADD THE TLX INCREMENT
	ADD	A7,A2			;ADD THE TLY INCREMENT
	ADD	A8,A3			;ADD THE LRX INCREMENT
	ADD	A9,A4			;ADD THE LRY INCREMENT
	MMTM	A12,A1,A2,A3,A4,A5,A6,A7
	SRL	16,A1
	MOVY	A2,A1
	MOVE	A1,@SCRNTL,L
	SRL	16,A3
	MOVY	A4,A3
	MOVE	A3,@SCRNLR,L
	SLEEP	1
	MMFM	A12,A1,A2,A3,A4,A5,A6,A7
	DSJS	A5,SHTIMLP
SHTIMR
	MOVE	A10,@SCRNTL,L		;MATCH WHAT THE CALLER WANTED
	MOVE	A11,@SCRNLR,L
	RETP

**************************************************************************
* GET_PT_SCRNREL
*  GET THE SCREEN RELATIVE X COOR OF A PLANE RELATIVE POINT.
* A0 = X point (XPOS not XVAL)
* A1 = PLANE #
* RETURNS
* A0 = X SCREEN RELATIVE, 16 BITS
GET_PT_SCRNREL
	PUSH	A1
	movi	PLNSIZ,A14
	mpyu	A14,A1
	addi	FGLISTS,A1
	move	*A1(P_XPOS+010h),A14,W
	sub	A14,A0
	PULLQ	A1
	RETS

**************************************************************************
* GET_Y_SCRNREL
*  GET THE SCREEN RELATIVE Y COOR OF A PLANE RELATIVE POINT.
* A0 = X point (YPOS not YVAL)
* A1 = PLANE #
* RETURNS
* A0 = Y SCREEN RELATIVE, 16 BITS
GET_Y_SCRNREL
	PUSH	A1
	movi	PLNSIZ,A14
	mpyu	A14,A1
	addi	FGLISTS,A1
	move	*A1(P_YPOS+010h),A14,W
	sub	A14,A0
	PULLQ	A1
	RETS

**************************************************************************
* GET_PT_PLANEREL
*  MAKE SCREEN RELATIVE X COOR BE A PLANE RELATIVE POINT.
* A0 = X point (XPOS not XVAL)
* A1 = PLANE #
* RETURNS
* A0 = X SCREEN RELATIVE, 16 BITS
GET_PT_PLANEREL
	PUSH	A1
	movi	PLNSIZ,A14
	mpyu	A14,A1
	addi	FGLISTS,A1
	move	*A1(P_XPOS+010h),A14,W
	add	A14,A0
	PULLQ	A1
	RETS

**************************************************************************
*                                                                        *
* GET_SCRNREL - GET THE SCREEN RELATIVE X,Y COORDINATES OF AN OBJECT	 *
* 	   IT IS ASSUMED THATE THE CURRENT X,Y COORDINATES ARE		 *
* 	   WORLD ABSOLUTE.						 *
* A8 = PTR TO THE OBJECT BLOCK			 			 *
* RETURNS								 *
* A1 = X SCREEN RELATIVE, 32 BITS					 *
* A2 = Y SCREEN RELATIVE, 32 BITS					 *
*                                                                        *
**************************************************************************
GET_SCRNREL
	MOVB	*A8(OFLAGS+B_NOSCROLL-7),A14	;IS THIS A SCREEN OBJ
	JRN	GS_SCRNXY
	PUSH	A5
	movb	*A8(OPLANE),A5
	movi	PLNSIZ,A14
	mpyu	A14,A5
	addi	FGLISTS,A5
	move	*A5(P_XPOS+010h),A14,W
	MOVE	*A8(OXPOS),A1,W
	SUB	A14,A1
	SLL	16,A1
	move	*A5(P_YPOS+010h),A14,W
	MOVE	*A8(OYPOS),A2,W
	SUB	A14,A2
	SLL	16,A2
	PULLQ	A5
	RETS
*JUST GRAB THE SCREEN RELATIVE COORDS
GS_SCRNXY
	MOVE	*A8(OXPOS),A1,W
	SLL	16,A1
	MOVE	*A8(OYPOS),A2,W
	SLL	16,A2
	RETS

**************************************************************************
*								         *
* MAKE_SCRNREL - MAKE A GIVEN OBJECT HAVE SCREEN RELATIVE COORDINATES.	 *
* 	   THEY ARE PASSED BACK FOR YOUR USE.				 *
* A8 = PTR TO THE OBJECT BLOCK						 *
* RETURNS								 *
* A1 = X SCREEN RELATIVE, 32 BITS					 *
* A2 = Y SCREEN RELATIVE, 32 BITS					 *
*								         *
**************************************************************************
MAKE_SCRNREL
	PUSH	A5
	movb	*A8(OPLANE),A5
	movi	PLNSIZ,A14
	mpyu	A14,A5
	addi	FGLISTS,A5
	move	*A5(P_XPOS+010h),A14,W
	MOVE	*A8(OXPOS),A1,W
	SUB	A14,A1
	MOVE	A1,*A8(OXPOS),W
	SLL	16,A1
	move	*A5(P_YPOS+010h),A14,W
	MOVE	*A8(OYPOS),A2,W
	SUB	A14,A2
	MOVE	A2,*A8(OYPOS),W
	SLL	16,A2
	PULLQ	A5
	RETS

**************************************************************************
*								         *
* MAKE_WORLDREL - MAKE A GIVEN OBJECT HAVE WORLD RELATIVE COORDINATES.	 *
* 	   THEY ARE PASSED BACK FOR YOUR USE.				 *
* A8 = PTR TO THE OBJECT BLOCK						 *
* RETURNS								 *
* A1 = X SCREEN RELATIVE, 32 BITS					 *
* A2 = Y SCREEN RELATIVE, 32 BITS					 *
*								         *
**************************************************************************
MAKE_WORLDREL
	PUSH	A5
	movb	*A8(OPLANE),A5
	movi	PLNSIZ,A14
	mpyu	A14,A5
	addi	FGLISTS,A5
	move	*A5(P_XPOS+010h),A14,W
	MOVE	*A8(OXPOS),A1,W
	ADD	A14,A1
	MOVE	A1,*A8(OXPOS),W
	SLL	16,A1
	move	*A5(P_YPOS+010h),A14,W
	MOVE	*A8(OYPOS),A2,W
	ADD	A14,A2
	MOVE	A2,*A8(OYPOS),W
	SLL	16,A2
	PULLQ	A5
	RETS

**************************************************************************
*								         *
* MAKEWORLDREL - MAKE A GIVEN OBJECT HAVE WORLD RELATIVE COORDINATES.	 *
* 	   THEY ARE PASSED BACK FOR YOUR USE. (A0 VERSION)		 *
* A0 = PTR TO THE OBJECT BLOCK						 *
* RETURNS								 *
* A1 = X SCREEN RELATIVE, 32 BITS					 *
* A2 = Y SCREEN RELATIVE, 32 BITS					 *
*								         *
**************************************************************************
MAKEWORLDREL
	PUSH	A8
	MOVE	A0,A8
	CALLR	MAKE_WORLDREL
	PULLQ	A8
	RETS

**************************************************************************
*								         *
* PNT_WORLDREL - MAKE A GIVEN POINT WORLD RELATIVE IN A GIVEN PLANE.	 *
* 		POINT IS ASSUMED TO BE SCREEN RELATIVE.			 *
* A1 = PLANE OF WHICH TO MAKE POINT RELATIVE				 *
* A3 = [Y,X] SCREEN RELATIVE POINT					 *
* RETURNS								 *
* 	A3 = [Y,X] WORLD PLANE RELATIVE					 *
*								         *
**************************************************************************
PNT_WORLDREL
	MMTM	SP,A1,A2
	MOVI	FGLISTS,A2
	JRUC	PW_G
*BACKGROUND PLANE VERSION
PNT_WORLDRELBG
	MMTM	SP,A1,A2
	MOVI	BGLISTS,A2
PW_G
	movi	PLNSIZ,A14
	mpyu	A14,A1
	ADD	A2,A1
	move	*A1(P_XPOS+010h),A14,W
	move	*A1(P_YPOS+010h),A1,W
	SLL	16,A1
	MOVY	A1,A14
	ADDXY	A14,A3	
	MMFM	SP,A1,A2
	RETS

**************************************************************************
*								         *
* PNT_SCRNREL - MAKE A GIVEN POINT SCREEN RELATIVE FROM A GIVEN PLANE.	 *
* 		POINT IS ASSUMED TO BE WORLD RELATIVE.			 *
* A1 = PLANE OF WHICH FROM WHICH TO TAKE POINT 				 *
* A3 = [Y,X] WORLD/PLANE RELATIVE POINT					 *
* RETURNS								 *
* 	A3 = [Y,X] SCREEN RELATIVE					 *
*								         *
**************************************************************************
PNT_SCRNREL
	MMTM	SP,A1,A2
	MOVI	FGLISTS,A2
	movi	PLNSIZ,A14
	mpyu	A14,A1
	ADD	A2,A1
	move	*A1(P_XPOS+010h),A14,W
	move	*A1(P_YPOS+010h),A1,W
	SLL	16,A1
	MOVY	A1,A14
	SUBXY	A14,A3	
	MMFM	SP,A1,A2
	RETS

**************************************************************************
*                                                                        *
* COPY_OBJ - COPIES THE CONTENTS OF ONE OBJECT BLOCK TO THE OTHER.	 *
* A0 = PTR TO DESTINATION BLOCK						 *
* A8 = PTR TO SOURCE BLOCK						 *
* NOTE: TRASHES A14							 *
*                                                                        *
* JFL 02 OCT 92; REORDERED OBJ BLOCK
**************************************************************************
OCOPYSTART EQU OFSET
COPY_OBJ:
	MMTM	SP,A0,A8
	MOVI	OBSIZ-OCOPYSTART,A14	;GET THE SIZE OF THE BLOCK IN WORDS
	ADDI	OCOPYSTART,A0
	ADDI	OCOPYSTART,A8

	SRL	5,A14			;DIVIDE BY 32
	JRNC	SKIP_COPYOBJ_WRD	;BR = NO ODD WORDS
	MOVE	*A8+,*A0+,W		;TAKE CARE OF ODD MAN
SKIP_COPYOBJ_WRD:
	SRL	1,A14
	JRNC	COPYOBJ_LP
	MOVE	*A8+,*A0+,L		;MOVE A LONG
COPYOBJ_LP
	move	*A8+,*A0+,L
	move	*A8+,*A0+,L
	DSJS	A14,COPYOBJ_LP

	MMFM	SP,A0,A8

	;CLEAN ANYTHING THAT NEEDS IT
	MOVE	*A0(OFLAGS),A14,W
	ANDNI	M_ANIM,A14		;CLEAR ANY IRRELEVANT FLAGS HERE
	MOVE	A14,*A0(OFLAGS),W
	CLR	A14
	MOVL	A14,*A0(OSLINK)		;INVALID LINK
	MOVL	A14,*A0(OPARTS)		;INVALID LINK
	RETS

**************************************************************************
*								         *
* CREATE_COPY - CREATE A COPY OF THE GIVEN OBJECT.			 *
* A8 = OBJECT TO COPY							 *
* RETURNS								 *
* 	 Z = FAILURE ALLOCATING COPY					 *
* 		A0 = 0							 *
* 	NZ = COPY SUCCESSFULL						 *
* 		A0 = PTR TO COPY OBJECT					 *
*								         *
**************************************************************************
CREATE_COPY
	CALLR	GETOBJ
	JRZ	CC_X
	CALLR	COPY_OBJ
	PUSH	A5
	MOVE	*A0(OPAL),A5,W
	CALLA	INC_PALCNT
	PULLQ	A5
	MOVE	A0,A0
CC_X
	RETS



**************************************************************************
*								         *
* KILOBJ_ALL - KILL ALL OBJECTS OF THE GIVEN I.D.			 *
* A0 = OID (16 BITS)							 *
*								         *
**************************************************************************
KILOBJ_ALL:	
	PUSH	A1
	CLR	A1
	NOT	A1
	CALLR	KILOBJ
	PULLQ	A1
	RETS

**************************************************************************
*								         *
* KILOBJ - KILL A CLASS OF OBJECTS ON ALL FOREGROUND PLANES		 *
* A0 = OID (16 BITS)							 *
* A1 = MASK: MASK BITS OF ZERO ARE DONT CARES (16 BITS)			 *
*								         *
**************************************************************************
KILOBJ
	MMTM	SP,A6,A8
	MOVE	@FGPLANECT,A6,W
	JRZ	KO_X
	MOVI	FGLISTS,A8
KO_LP
	CALLR	KILOBJ_PLANE
	ADDI	PLNSIZ,A8
	DSJS	A6,KO_LP
KO_X
	MMFM	SP,A6,A8
	RETS

**************************************************************************
*								         *
* KILOBJ_PLANE - KILL A CLASS OF OBJECTS ON A GIVEN PLANE.		 *
* A0 = OID (16 BITS)							 *
* A1 = MASK: MASK BITS OF ZERO ARE DONT CARES (16 BITS)			 *
* A8 = PTR TO THE PLANE STRUCTURE					 *
*								         *
**************************************************************************
KILOBJ_PLANE:	
	MMTM	SP,A0,A2,A3

	MOVE	A0,A2
	SEXT	A2
	AND	A1,A2		;FORM MATCH

	MOVE	A8,A0
	JRUC	KOP_TST

KOP_LP	
	MOVE	*A0(OID),A14
	AND	A1,A14		;CAN DONT CARE BITS
	CMP	A2,A14		;MATCH?
	JRNE	KOP_TST		;NO

	MOVE	*A0,A3,L
	CALLR	DELOBJ
	MOVE	A3,A0
	JRUC	KOP_TST2
KOP_TST
	MOVE	*A0,A0,L
KOP_TST2
	CMP	A0,A8
	JRNE	KOP_LP

KILOBX:	
	MMFM	SP,A0,A2,A3
	RETS

**************************************************************************
*								         *
* EXISTOBJ_ALL - FIND ANY OCCURANCE OF AN OBJECT OF GIVEN I.D.		 *
* A0 = OID								 *
* RETURNS:								 *
* 	Z BIT SET = NO OBJECT, A0 = 0					 *
* 	Z BIT CLR = OBJECT, A0 = PTR TO OBJECT				 *
*								         *
**************************************************************************
EXISTOBJ_ALL
	PUSH	A1
	CLR	A1
	NOT	A1
	CALLR	EXISTOBJ
	PULL	A1
	RETS

**************************************************************************
*								         *
* EXISTOBJ - DOES AN OBJECT FROM A CERTAIN CLASS EXIST			 *
* 		IN ANY PLANE?						 *
* A0 = OID								 *
* A1 = MASK(0'S DON'T CARE)						 *
* RETURNS:								 *
* 	Z BIT SET = NO OBJECT, A0 = 0					 *
* 	Z BIT CLR = OBJECT, A0 = PTR TO OBJECT				 *
*								         *
**************************************************************************
EXISTOBJ
	MMTM	SP,A2,A6,A8
	MOVE	@FGPLANECT,A6,W
	JRZ	EO_X
	MOVE	A0,A2
	MOVI	FGLISTS,A8
EO_LP
	CALLR	EXISTOBJ_PLANE
	JRNZ	EO_X		       	;BR = FOUND ONE ON THIS PLANE
	MOVE	A2,A0			;RESTORE OID
	ADDI	PLNSIZ,A8
	DSJS	A6,EO_LP
	SETZ				;FAILED ON ALL ACCOUNTS
EO_X
	MMFM	SP,A2,A6,A8
	RETS

**************************************************************************
*								         *
* EXISTOBJ_PLANE - DOES AN OBJECT FROM A CERTAIN CLASS EXIST		 *
* 		IN A GIVEN PLANE?					 *
* A0 = OID								 *
* A1 = MASK(0'S DON'T CARE)						 *
* A8 = PTR TO THE PLANE STRUCTURE					 *
* RETURNS:								 *
* 	Z BIT SET = NO OBJECT, A0 = 0					 *
* 	Z BIT CLR = OBJECT, A0 = PTR TO OBJECT				 *
*								         *
**************************************************************************
EXISTOBJ_PLANE:	
	MMTM	SP,A2,A3

	MOVE	A0,A2
	SEXT	A2
	AND	A1,A2		;FORM MATCH

	MOVE	A8,A0
	JRUC	EOP_TST

EOP_LP	
	MOVE	*A0(OID),A14
	AND	A1,A14		;CAN DONT CARE BITS
	CMP	A2,A14		;MATCH?
	JREQ	EOP_X		;YES!

EOP_TST
	MOVE	*A0,A0,L
	CMP	A0,A8
	JRNE	EOP_LP
	CLR	A0
EOP_X:	
	MOVE	A0,A0
	MMFM	SP,A2,A3
	RETS

**************************************************************************
*								         *
* COUNT_HEADS_PLANE - COUNT ONLY THE HEAD PARTS OF MULTI-PART OBJECTS	 *
* 			ON A GIVEN PLANE				 *
* A0 = OID (16 BITS) TO COUNT						 *
* A1 = MASK: MASK BITS OF ZERO ARE DONT CARES (16 BITS)			 *
* A2 = PTR TO THE PLANE STRUCTURE					 *
* RETURNS								 *
* 	A6 = COUNT							 *
*								         *
**************************************************************************
COUNT_HEADS_PLANE
	MMTM	SP,A0,A3

	MOVE	A0,A3
	SEXT	A3
	AND	A1,A3		;FORM MATCH

	CLR	A6

	MOVE	A2,A0
	JRUC	CHP_TST

CHP_LP	
	MOVE	*A0(OID),A14
	AND	A1,A14		;CAN DONT CARE BITS
	CMP	A3,A14		;MATCH?
	JRNE	CHP_TST		;NO

	MOVE	*A0(OPART1),A14,L
	JRNZ	CHP_HEAD_TST	;BR = A MULTI-PARTER
	INC	A6		;COUNT THE SOLO OBJECT
	JRUC	CHP_TST
CHP_HEAD_TST
	CMP	A0,A14		;IS THIS THE HEAD?
	JRNE	CHP_TST		;BR = NO
	INC	A6
CHP_TST
	MOVE	*A0,A0,L
	CMP	A0,A2
	JRNE	CHP_LP

	MMFM	SP,A0,A3
	RETS

**************************************************************************
*								         *
* FIND_HEAD_PLANE - FIND A HEAD PART ON A PLANE THAT MATCHES THE	 *
* 		  GIVEN I.D.						 *
* A0 = OID (16 BITS) TO COUNT						 *
* A1 = MASK: MASK BITS OF ZERO ARE DONT CARES (16 BITS)			 *
* A2 = PTR TO THE PLANE STRUCTURE					 *
* RETURNS								 *
* 	 Z = NONE FOUND							 *
* 		A0 = 0							 *
* 	NZ = FOUND ONE							 *
* 		A0 = PTR TO OBJECT					 *
*								         *
**************************************************************************
FIND_HEAD_PLANE
	PUSH	A3

	MOVE	A0,A3
	SEXT	A3
	AND	A1,A3		;FORM MATCH

	MOVE	A2,A0
	JRUC	FHP_TST

FHP_LP	
	MOVE	*A0(OID),A14
	AND	A1,A14		;CAN DONT CARE BITS
	CMP	A3,A14		;MATCH?
	JRNE	FHP_TST		;NO

	MOVE	*A0(OPART1),A14,L
	JRZ	FHP_TST		;BR = NOT A MULTI-PARTER
	CMP	A0,A14		;IS THIS THE HEAD?
	JRNE	FHP_TST		;BR = NO
	MOVE	A0,A0
	JRUC	FHP_X
FHP_TST
	MOVE	*A0,A0,L
	CMP	A0,A2
	JRNE	FHP_LP
     	CLR	A0
FHP_X
	PULL	A3
	RETS


**
** SETGCOL -- EXGPC B8
**
** NOTE: USE THE FIELD OGCOL TO DETERMINE IF OBJ IS ON GCOLLIST
** 
** IN
**   A2 GCOL()
**   A8 OBJ
**
** JFL 10 JAN 93
**
SETGCOL
	.IF DEBUG
	MOVL	*A8(OGCOL),A14
	TLOCKON	NZ
	.ENDIF ;DEBUG

	;SET HANDLER
	MOVL	A2,*A8(OGCOL)

	;LINK INTO LIST
	MOVI	GCOLLIST,A2
	MOVL	*A2(0),*A8(OGCOLLINK)
	MOVL	A8,*A2

	EXGPC	B8

**
** CLRGCOL -- EXGPC B8
**
** IN
**   A2-A3 SCRATCH
**   A8 OBJ
**
** JFL 10 JAN 93
**
CLRGCOL
	;GET 1ST OBJ
	MOVL	@GCOLLIST,A3
	JRZ	CGCXBAD

	CMP	A3,A8
	JRNE	CGCLOOP

	;UNLINK FIRST
	MOVL	*A8(OGCOLLINK),A2
	MOVL	A2,@GCOLLIST
	CLR	A14
	MOVL	A14,*A8(OGCOL)
	JRUC	CGCX

CGCLOOP
	;GET NEXT
	MOVE	A3,A2			;SAVE PREV
	MOVL	*A3(OGCOLLINK),A3
	JRZ	CGCXBAD

CGCCHECK
	;IS THIS THE OBJ WE WANT
	CMP	A3,A8
	JRNE	CGCLOOP
	
	;UNLINK
	MOVL	*A3(OGCOLLINK),*A2(OGCOLLINK)
	CLR	A14
	MOVL	A14,*A8(OGCOL)
	
CGCX
	EXGPC	B8
CGCXBAD
	TLOCKUP
	EXGPC	B8

**
** GCOLWATCHER -- PROCESS
**
** JFL 01 OCT 92
** JFL 30 OCT 92; NO OFLAGS BIT
** JFL 10 JAN 93; GCOLLLIST
**
GCOLWATCHER
	;GET 1ST OBJ TO CHECK FOR GROUND COLLISION
	MOVL	@GCOLLIST,A8
	JRZ	GCWX

	;ZERO Q COUNT
	CLR	A1		;QCOUNT
	MOVI	J64Q,A9	 	;TOP OF Q

GCWLOOP
	;HAS IT HIT?	
	MOVL	*A8(OYACC),A14	
	JRNZ	GCWNEXT

	;Q IT UP
	INC	A1		;QCOUNT++
	MOVL	*A8(OGCOL),A14
	MOVL	A14,*A9+
	MOVL	A8,*A9+
	

GCWNEXT
	;NEXT OBJ
	MOVL	*A8(OGCOLLINK),A8
	JRNZ	GCWLOOP

	;ANY TO DO?
	MOVE	A1,A1
	JRZ	GCWX

	;TERM THE Q
	CLR	A14
	MOVL	A14,*A9

	;RESET TO TOP OF Q
	MOVI	J64Q,A9		;TOP OF Q
	JRUC	GCWPNEXT

GCWPLOOP
	;PULL OBJ & CALL
	MOVL	*A9+,A8		;GET OBJ
	MOVI	CLRGCOL,B8 	;FUNC IN A2-A3,A8 SC,OBJ
	EXGPC	B8 		;CLEAR OUT GCOL STUFF

	CALL	A0 ;IN: A0,A8 FUNC(),OBJ SC:A0-A8,A10-A11

GCWPNEXT
	;PULL FUNC
	MOVL	*A9+,A0		;GET FUNC	
	JRNZ	GCWPLOOP

GCWX
	SLEEP	2
	JRUC	GCOLWATCHER

	.END

* EOF

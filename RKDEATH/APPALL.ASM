***
*** FILE: APPALL.ASM
***
*** JFL 30 NOV 92; FOR TUNIT
*** JFL 01 DEC 92; ONLY ONE SET OF PALETTES
*** JFL 15 JAN 93; TLOCKS
*** JFL 12 APR 93; COMMENT ON PALCYCLEADD
***

	.MLIB	"APMACS.LIB"
	.FILE	"APPALL.ASM"
	.TITLE	"<<< AMUSEMENT PARK -- PALETTE ALLOCATOR V1.0 >>>"
	.WIDTH	132
	.OPTION	B,D,L,T
	.MNOLIST

**************************************************************************
*								         *
* 	COPYRIGHT (C) 1992 MIDWAY MANUFACTURING COMPANY.		 *
* 		       ALL RIGHTS RESERVED.				 *
*								         *
**************************************************************************

	.INCLUDE	"AP.H"		;System equates
	.INCLUDE	"DRPAL.I"

** OTHERS USE
	.DEF	PALSET		;APPALL.ASM
	.DEF	INIT_PAL	;APPALL.ASM
	.DEF	FREEPALCNT	;APPALL.ASM
	.DEF	PALCYCLEADD	;APPALL.ASM
	.DEF	PALTRANS	;APPALL.ASM
	.DEF	PALFXINIT	;APPALL.ASM

** WE USE
	.REF	PTRRAM
	.REF	WAVEIRQS
	.REF	PALRAM

** WE USE -- RAM
	.REF	PALFXFREELIST	;DRRAM.ASM
	.REF	PALFXRAM	;DRRAM.ASM
	.REF	PALFXRAMX	;DRRAM.ASM
	.REF	PALCYCLELIST	;DRRAM.ASM
	

	.BSS	FREEPALCNT,16,1

	.TEXT

**************************************************************************
*								         *
* CLR_0PALS - ROUTINE CLEAR THE PALID FIELD OF ANY PALETTE THAT HAS	 *
* 	    ZERO PEOPLE USING IT.					 *
*								         *
**************************************************************************
CLR_0PALS
	PUSH	A1
	MOVI	NUMPAL,B14
	MOVI	PALRAM,A1	
C0_LP
	MOVE	*A1(PALCNT),A14,W	;CHECK ALLOCATION COUNT.
	JRNZ	C0_NXT			;BR = THIS ONE IS IN USE
	MOVE	A14,*A1(PALID),L	;CLEAR THE I.D.
C0_NXT
	ADDI	PALRSIZ,A1
	DSJS	B14,C0_LP
	PULLQ	A1
	RETS
	
**************************************************************************
*								         *
* INC_PALCNT -INCREMENT THE PALETTE COUNT BY WAY OF THE PALETTE #	 *
* A5 = PALETTE NUMBER							 *
*								         *
**************************************************************************
INC_PALCNT
	PUSH	A5
	SLL	24,A5
	SRL	24,A5		;MASK OFF ANY NON-SENSE

	.IF	YUNIT
	MOVE	A5,A14
	SLL	28,A5
	SRL	28,A5		;STRIP OFF TOP BITS
	SRL	6,A14		;MOVE BITS 6 & 7 
	SLL	4,A14		;TO BITS 4 & 5
	OR	A14,A5
	.ENDIF ;YUNIT

	MOVI	PALRSIZ,A14
	MPYU	A14,A5
	ADDI	PALRAM,A5
	INCM	*A5(PALCNT),W		;INCREMENT THAT PALETTE COUNT
	PULLQ	A5
	RETS

**************************************************************************
*								         *
* A_CHANGE_PAL - ANIM FUNC TO CHANGE THE PALETTE TO THE GIVEN		 *
* A8 = PTR TO OBJECT							 *
* *A8(AnimFrm),L = PTR TO PALETTE I.D.					 *
* NOTE: ANIM FUNCS DO NOT PUSH REGISTERS!				 *
*								         *
**************************************************************************
A_CHANGE_PAL
	CALLA	GETAFARG_LONG
	CALLR	CHANGE_PAL
	RETS

**************************************************************************
*								         *
* GET_PALID - ROUTINE TO RETURN THE I.D. OF AN ALLOCATED PALETTE.	 *
* A0 = CURRENT PALETTE NUMBER						 *
* RETURNS:								 *
* A0 = PALETTE I.D.							 *
*								         *
**************************************************************************
GET_PALID
	PUSH	A1
	SLL	24,A0		;MASK OFF GARBAGE
	SRL	24,A0

	.IF	YUNIT
	MOVE	A0,A1		;MOVE BITS 6,7 INTO 4,5 FOR YUNIT
	SLL	28,A0
	SRL	28,A0
	SRL	6,A1
	SLL	4,A1
	ADD	A1,A0
	.ENDIF ;YUNIT

	CMPI	NUMPAL,A0 	;ERROR...PALETTE NUMBER ERRONEOUS
	JRLO	GPID_1
	TLOCKUP
	CLR	A0
GPID_1

	MOVI	PALRSIZ,A1
	MPYU	A0,A1
	ADDI	PALRAM,A1
	MOVE	*A1,A0,L
	PULL	A1
	RETS

**************************************************************************
*								         *
* CHANGE_PAL - CHANGE AN OBJECTS CURRENT PALETTE TO A NEW ONE.		 *
* 		DELETES THE OBJECTS OLD PALETTE.			 *
* 		IF NO NEW PALETTES ARE AVAILABLE, THEN PALETTE		 *
* 		0 IS STUFFED.						 *
* A0 = I.D. OF NEW PALETTE						 *
* A8 = OBJECT								 *
* RETURNS:								 *
* 	 Z = FAILURE ALLOCATING NEW PALETTE				 *
* 		A0 = 0							 *
* 	NZ = PALETTE CHANGE SUCCESSFUL.					 *
* 		A0 = NEW PALETTE NUMBER					 *
*								         *
**************************************************************************
CHANGE_PAL
	CALLR	DELETE_PAL		;DELETE OLD
	CALLA	GETFPAL			;GET A COLOR MAP ASSIGNMENT
	JRNZ	CP_SUCCESS		;BR = USE IT
	MOVE	*A8(OPAL),A0,W		;GET THE OLD PALETTE
	CALLA	GET_PALID
	CALLA	GETFPAL			;RESTORE OLD ASSIGNMENT
CP_SUCCESS
	MOVE	A0,*A8(OPAL),W		;STORE THE NEW PALETTE
	RETS

**************************************************************************
*								         *
* CHANGE_PAL_MULTI - CHANGE THE PALETTE OF A MULTI-PART OBJECT		 *
* 		   FROM THE GIVEN OBJECT ON DOWN.			 *
* A0 = PTR TO NEW PALETTE						 *
* A8 = PTR TO PART							 *
*								         *
**************************************************************************
CHANGE_PAL_MULTI
	MMTM	SP,A1,A8
	MOVE	A0,A1
CPM_LP
	CALLR	CHANGE_PAL
	MOVE	A1,A0			;RESTORE PALETTE I.D.
	MOVE	*A8(OPARTS),A8,L
	JRNZ	CPM_LP
CPM_X
	MMFM	SP,A1,A8
	RETS

**************************************************************************
*								         *
* DELETE_PAL - DELETE AN OBJECTS PALETTE				 *
* A8 = PTR TO OBJECT							 *
*								         *
**************************************************************************
DELETE_PAL:
	PUSH	A0
	MOVE	A8,A0
	CALLR	DELPAL
	PULL	A0
	RETS

**************************************************************************
*                                                                        *
* DELPAL - DELETE AN OBJECTS PALETTE					 *
* A0 = PTR TO OBJECT							 *
*                                                                        *
**************************************************************************
DELPAL
	RETS

	PUSH	A0
	MOVE	*A0(OPAL),A0,W
	CALLR	FREEPAL
	MMFM	SP,A0
	RETS

**************************************************************************
*                                                                        *
* FINDPAL - FIND THE COLOR MAP # TO WHICH THE GIVEN PALETTE IS ASSIGNED. *
* A0 = 32 BIT PALETTE ADDRESS 						 *
* RETURNS:								 *
* Z BIT SET = PALETTE NOT FOUND ---> A0 = 0				 *
* Z BIT CLR = PALETTE FOUND ---> A0 = PALETTE #(CORRECT FORMAT FOR DMA)	 *
*                                                                        *
**************************************************************************
FINDPAL
	MMTM	SP,A1,A2,A3
	MOVI	NUMPAL,A3
	MOVI	PALRAM,A1	
FINDPAL0
	MOVE	*A1,A2,L	;GET PALETTE ID
	CMP	A0,A2
	JREQ	FINDPAL1	;FOUND
	ADDI	PALRSIZ,A1
	DSJS	A3,FINDPAL0
	CLR	A0		;SET Z BIT ---> FAILURE
	JRUC	FINDPALX
FINDPAL1
	SUBI	NUMPAL,A3	;COMPUTE PALETTE #
	NEG	A3

	.IF	YUNIT
	MOVE	A3,A0		;MOVE BITS 4,5 TO 6,7 FOR YUNIT
	SLL	28,A3		;STRIP OFF BITS 4,5
	SRL	28,A3
	SRL	4,A0
	SLL	6,A0
	ADD	A0,A3
	.ENDIF ;YUNIT

	MOVE	A3,A0 	      	;RETURN PALETTE #
	SLL	8,A3
	ADD	A3,A0 		;DOUBLE IT UP FOR LOFFREDO BRAIN DAMAGE
	INC	A3		;CLR Z BIT ---> SUCCESS
FINDPALX
	MMFM	SP,A1,A2,A3
	RETS


**************************************************************************
*								         *
* INIT_PAL - GET A PALETTE FOR USE. THIS IS THE NEW VERSION.		 *
* A1 = POINTER TO IMAGE HEADER						 *
* RETURNS:								 *
* 	 Z = FAILURE							 *
* 		A0 = 0							 *
* 	NZ = SUCCESS							 *
* 		A0 = PALETTE NUMBER					 *
*								         *
**************************************************************************
INIT_PAL
	MOVE	*A1(ICMAP),A0,L		;GET THE PALETTE NAME
	JRUC	GETFPAL			;GET A PALETTE


**
** CLEAR OUT PALETTE ALLOCATION RAM
**
** JFL 25 MAR 93; CLEANED UP
**
CLRPAL
	MMTM	SP,A0,A1,A2
	
	.IF DEBUG
	MOVW	@DMACTRL,A14
	TLOCKON	N ;DMA CANT BE ON WHILE ACCESSING PAL RAM
	.ENDIF ;DEBUG

	MOVI	NUMPAL,A0
	MOVW	A0,@FREEPALCNT

	MOVI	PALRAM,A0
	MOVI	PALRSIZ*NUMPAL/32,A2
	CLR	A1
CLRPALP
	MOVL	A1,*A0+
	DSJ	A2,CLRPALP
CLRPTR
	MOVI	PTRRAM,A0
	MOVI	PTRSIZ*NUMPTR/16,A2
CLRPLP1
	MOVW	A1,*A0+
	DSJ	A2,CLRPLP1

	.IF DEBUG
	MOVW	@DMACTRL,A14
	TLOCKON	N ;DMA CANT BE ON WHILE ACCESSING PAL RAM
	.ENDIF ;DEBUG

	MMFM	SP,A0,A1,A2
	RETS

**************************************************************************
*								         *
* GETPAL - ALLOCATE A FOREGROUND PALETTE, IF THERE ARE NO FOREGROUND	 *
* 	  PALETTES LEFT, THEN IT WILL ATTEMPT TO ALLOCATE A		 *
* 	  BACKGROUND PALETTE.						 *
* A0 = PALETTE ID (ADDRESS OF COLOR DATA)				 *
* RETURNS:								 *
* 	 Z = FAILURE, NO PALETTES FREE					 *
* 		A0 = 0							 *
* 	NZ = PALETTE ALLOCATED						 *
* 		A0 = COLOR MAP (0000 - 7F7F)				 *
*								         *
* JFL 01 DEC 92; REDONE
*
**************************************************************************
GETFPAL
	MMTM	SP,A1,A2,A3

	CMPI	ROM,A0
	JRHS	GFP_1
	TLOCKUP
	CLR	A0
	JRUC	GFPX
GFP_1

	;CHECK IF PALETTE ALREADY EXISTS
	MOVI	NUMPAL,A3
	MOVI	PALRAM,A1	
GPEXISTLOOP
	MOVL	*A1,A2		;GET PALETTE ID
	CMP	A0,A2
	JREQ	GPSHARE		;ALREADY IN COLOR RAM
	ADDI	PALRSIZ,A1
	DSJ	A3,GPEXISTLOOP

	;CHECK FOR A SPARE PALETTE
	MOVI	PALRAM,A1
	MOVI	NUMPAL,A3      		;CHECK ALL PALETTES
GPSPARELOOP
	MOVW	*A1(PALCNT),A2
	JRNZ	GPSPARENEXT

	;CHECK TIME WHEN FREED, CAN'T REALLOCATE ON SAME TIK
	MOVW	*A1(PALTIME),A2
	JRZ	GPALLOC
	MOVW	@WAVEIRQS,A14		;ONLY NEED THE BOTTOM 16 BITS
	CMP	A2,A14
	JRNE	GPALLOC

GPSPARENEXT
	ADDI	PALRSIZ,A1
	DSJ	A3,GPSPARELOOP

	;FAIL
	TLOCKUP ;SHOULD NEVER HAPPEN
	CLR	A0
	JRUC	GFPX

GPALLOC
	DECM	@FREEPALCNT,W
	MMTM	SP,A0,A1,A2
	MOVE	A3,A1		;PALETTE #
	SUBI	NUMPAL,A1	;COMPUTE PALETTE #
	NEG	A1

	.IF	YUNIT
	MOVE	A1,A2		;MOVE BITS 4,5 TO 6,7 FOR YUNIT
	SLL	28,A1		;STRIP OFF BITS 4,5
	SRL	28,A1
	SRL	4,A2
	SLL	6,A2
	ADD	A2,A1
	.ENDIF

	SLL	8,A1		;X 256
	MOVW	*A0+,A2		;GET # COLORS IN PALETTE
	CALLR	PALSET		;SETUP PALETTE TRANSFER
	MMFM	SP,A0,A1,A2
	TLOCKON	Z
	JRZ	GFPX		;FAILED TO GET TRANSFER
	MOVL	A0,*A1		;STUFF PALETTE I.D.

GPSHARE
	SUBI	NUMPAL,A3	;COMPUTE PALETTE #
	NEG	A3

	.IF	YUNIT
	MOVE	A3,A0		;MOVE BITS 4,5 TO 6,7 FOR YUNIT
	SLL	28,A3		;STRIP OFF BITS 4,5
	SRL	28,A3
	SRL	4,A0
	SLL	6,A0
	ADD	A0,A3
	.ENDIF

	MOVE	A3,A0 	      	;RETURN PALETTE #
	SLL	8,A3
	ADD	A3,A0	      		;DOUBLE IT UP FOR LOFREDO BRAIN DAMAGE
	MOVW	*A1(PALCNT),A2		;INCREMENT COUNT
	INC	A2			;SET NE FOR SUCCESS 
	MOVW	A2,*A1(PALCNT)

GFPX
	MMFM	SP,A1,A2,A3
	RETS

*	
*FREE A PALETTE	
*A0=PALETTE # (0-NUMPAL) TO FREE
*
FREEPAL	
	RETS

	MMTM	SP,A0,A1
	SLL	24,A0		;MASK OFF GARBAGE
	SRL	24,A0

	.IF	YUNIT
	MOVE	A0,A1		;MOVE BITS 6,7 INTO 4,5 FOR YUNIT
	SLL	28,A0
	SRL	28,A0
	SRL	6,A1
	SLL	4,A1
	ADD	A1,A0
	.ENDIF

	CMPI	NUMPAL,A0 	;ERROR...PALETTE NUMBER ERRONEOUS
	JRLO	FREEPAL1

	TLOCKUP
	JRUC	FREPLX

FREEPAL1
	MOVI	PALRSIZ,A1
	MPYU	A0,A1
	ADDI	PALRAM,A1
	MOVE	*A1(PALCNT),A0,W
	DEC	A0    			;DECREMENT ITS COUNT
	JRNN	FREEPAL2

	TLOCKUP
	JRUC	FREPLX

FREEPAL2
	MOVE	A0,*A1(PALCNT),W
	JRP	SkPalFree
	INCM	@FREEPALCNT,W
	;RECORD TIME WHEN FREED, CAN'T REALLOCATE ON SAME TIK
	MOVE	@WAVEIRQS,A0,W		;ONLY NEED THE BOTTOM 16 BITS
	MOVE	A0,*A1(PALTIME),W
SkPalFree

FREPLX:
	MMFM	SP,A0,A1
	RETS


*	
*SETUP PALETTE TRANSFER
*CALLING PARAMETERS:
*A0= PALSRC = 32 BIT SOURCE ADDRESS OF PALETTE COLOR DATA 	
*A1= PALDEST = BIT 8-15 DESTINATION PALETTE | BIT 0-7 START COLOR
*A2= PLDCNT = 16 BIT COLOR COUNT
*RETURNS: EQ IF UNABLE TO SETUP TRANSFER, NE IF TRANSFER O.K.
*
PALSET:
	MMTM	SP,A3,A4,A5
	MOVI	PTRRAM,A4
	MOVK	NUMPTR,A3	;# OF PALETTE TRANSFERS ALLOWED
PALSTL:
	MOVE	*A4,A5,W	;CELL TAKEN ?
	JRNE	PALST1		;YES, KEEP LOOKING
	MOVE	A0,*A4(PALSRC),L	;NO, LOAD IT UP
	MOVE	A1,*A4(PALDEST),W
	MOVE	A2,*A4(PLDCNT),W
	JRUC	PALSTX
PALST1:	
	ADDI	PTRSIZ,A4
	DSJS	A3,PALSTL
	TLOCKUP ;WONT TRANSFER
PALSTX:	
	MOVE	A3,A3		;RETURN EQ(NOT ABLE TO LOAD) OR NE (OK)
	MMFM	SP,A3,A4,A5
	RETS

**
** PALTRANS -- EXGPC B8 -- ROUTINE TO DO PALETTE STUFF DURING DIRQ
**
** PTRRAM = PALETTE TRANSFER AREA
** NOTE: TRASHES A0 - A13
**
** JFL 25 FEB 93
**
PALTRANS:
	MOVI	PTRRAM,A0
	MOVK	NUMPTR,A3 	;# OF PALETTES
PLTLP:
	MOVE	*A0,A4,W	;XFER TO DO
	JREQ	PLTX		;NO, QUIT
PLTGO:
	CLR	A1
	MOVE	A1,*A0+,W		;CLEAR OUT TRANFER COUNT
	MOVE	*A0+,A1,L		;SOURCE ADDRESS
	MOVE	*A0+,A2,W		;DESTINATION PALETTE

	.IF	YUNIT
*CONVERT TO COLOR RAM ADDRESS
*MOVE B14,15 TO B6,7
	MOVE	A2,A5
	SLL	20,A5
	SRL	20,A5
	SLL	16,A2
	SRL	30,A2
	SLL	6,A2
	ADD	A5,A2
	.ENDIF

	SLL	4,A2			;ADJUST FOR BIT ADDR
	ADDI	COLRAM,A2		;ADD IN COLOR RAM BASE ADDRESS

	.ALIGN ;ENSURE CACHE BOUNDRY
	SRL	1,A4			;ODD DATA COUNT
	JRNC	PLTGO1			;NOPE
	MOVE	*A1+,*A2+,W
PLTGO1:
	SRL	1,A4			;/2 DATA COUNT
	JRNC	PLTGO2			;NOPE
	MOVE	*A1+,*A2+,L
PLTGO2:
	SRL	1,A4			;/2 DATA COUNT
	JRNC	PLTGO3			;NOPE
	MOVE	*A1+,*A2+,L
	MOVE	*A1+,*A2+,L
PLTGO3:
	JREQ	PLTGO4			;DONE
	MOVE	*A1+,*A2+,L
	MOVE	*A1+,*A2+,L
	MOVE	*A1+,*A2+,L
	MOVE	*A1+,*A2+,L
	DSJS	A4,PLTGO3
PLTGO4
	DSJ	A3,PLTLP	;DONE
PLTX	
	JRUC	PALCYCLE

**
** PALCYCLE -- DIRQ INTERRUPT SUBROUTINE -- EXGPC B8
**
** SCRATCH: A0-A11
**		
** JFL 25 FEB 93
** JFL 08 APR 93; VEL BASED COLOR CYCLING
**
PALCYCLE
	MOVL	@PALCYCLELIST,A0	
	JRZ	PCX

	MOVL	@WAVEIRQS,A9
	MOVI	COLRAM,A8

PCLOOP
	;CHECK IF ITS TIME TO CYCLE
	MOVL	*A0(PFXIRQ),A14
	CMP	A9,A14
	JRHI	PCNEXT
	MOVW	*A0(PFXTIME),A2	
	ADD	A9,A2
	MOVL	A2,*A0(PFXIRQ)

	MOVL	*A0(PFXFIRST),A2	;VEL.8,COUNT.8:FIRST
	MOVE	A2,A3
	ZEXT	A2,W			;FIRST
	.IF DEBUG
	CMPI	NUMPAL<<8,A2
	TLOCKON	HS
	.ENDIF ;DEBUG
	SLL	4,A2			;ADJUST FOR BIT ADDR
	ADD	A8,A2			;ADD IN COLOR RAM BASE ADDRESS

	;BREAK APART THE VEL-COUNT-FIRST REGISTER
	MOVE	A3,A1			;VEL.8,COUNT.8:JUNK
	SLL	16-8,A3			;LOP OFF TOP BITS OF VEL
	SRL	32-8,A3			;COUNT REMAINING
	SRA	32-8,A1			;VEL
	TLOCKON	Z ;CANT HAVE ZERO VEL

	;SET UP SOME MORE
	MOVE	A3,A4			;COUNT TOTAL
	SLL	4,A4			;COUNT TOP IN WORDS (ONE PAST)
	SLL	4,A1			;VEL IN WORDS
	CLR	A5			;CUR COLOR
	MOVE	A2,A10			;DST
	MOVW	*A10,A11		;BOUNCED COLOR
	DEC	A3
	JRP	PCNOTSWAP

	;SIMPLE SWAP OF TWO COLORS
	MOVW	*A10(10H),A14		;GET TOP COLOR
	SLL	16,A11
	OR	A14,A11 
	MOVL	A11,*A10
	JRUC	PCNEXT

PCNOTSWAP

	;REG USE
	;  A0 PFX LINK
	;  A1 VEL IN WORDS
	;  A2 COL BASE (FIRST COLOR IN COLOR RAM)
	;  A3 COUNT REMAINING
	;  A4 COUNT TOP IN WORDS (THIS IS ONE PAST LAST VALID POS)
	;  A5 CUR COLOR
	;  A6 SCRATCH
	;  A7 
	;  A8 WAVEIRQS
	;  A9 COLRAM BASE
	; A10 DEST
	; A11 BOUNCING COLOR

	;
	;DIVIDE TASK UP TO EITHER THE POSITIVE OR NEGATIVE WAY
	;
	MOVE	A1,A1
	JRN	PCNEG

	;
	;POSITIVE DIRECTION
	;

PCPLOOP
	;FIGURE SRC
	ADD	A1,A5			;ADD IN VEL
	CMP	A4,A5			;CHECK IF WE HAVE OVERSHOT END
	JRLO	PCPOK

	;WE HAVE OVERSHOT, BACK UP
	SUB	A4,A5			;BACK UP
	
PCPOK
	;COPY OVER THE JUST BOUNCED COLOR
	MOVE	A5,A6			;CUR COLOR
	ADD	A2,A6			;ADD IN COLOR BASE
	MOVW	*A6,*A10		;MOVE INTO PLACE
	MOVE	A6,A10			;DST <- SRC

	DSJ	A3,PCPLOOP

	MOVW	A11,*A10		;LAST COLOR

	JRUC	PCNEXT

	;
	;NEGATIVE DIRECTION
	;
PCNEG

PCNLOOP
	;FIGURE SRC
	ADD	A1,A5			;ADD IN VEL
	JRP	PCNOK

	;WE HAVE OVERSHOT, BACK UP
	ADD	A4,A5			;BACK UP
	
PCNOK
	;COPY OVER THE JUST BOUNCED COLOR
	MOVE	A5,A6			;CUR COLOR
	ADD	A2,A6			;ADD IN COLOR BASE
	MOVW	*A6,*A10		;MOVE INTO PLACE
	MOVE	A6,A10			;DST <- SRC

	DSJ	A3,PCNLOOP

	MOVW	A11,*A10		;LAST COLOR

	;
	;NEXT NODE IN PAL FX CHAIN
	;

PCNEXT
	;NEXT
	MOVL	*A0,A0
	JRNZ	PCLOOP
PCX
	EXGPC B8

**
** PALFXINIT
**
** SCRATCH: A0-A11
**
** JFL 25 FEB 93
**
PALFXINIT
	GETST	B14
	DINT

	CLR	A3			;COUNT
	MOVL	A3,@PALCYCLELIST
	MOVI	PALFXFREELIST,A0
	MOVI	PALFXRAM,A1
       	JRUC	PFXILOOP

PFXILOOP
	;LINK FROM PREV TO THIS
	MOVL	A1,*A0
	INC	A3			;COUNT++
	
	;NEXT
	MOVE	A1,A0
	ADDI	PFXSIZE,A1
	CMPI	PALFXRAMX,A1
	JRLO	PFXILOOP

	CLR	A14
	MOVL	A14,*A0

	PUTST	B14
	RETS

**
** PALFXGET
**
** OUT
**   A0 NODE
**
** WARNING: CALLER MUST PROTECT THIS WITH DINT
**
** JFL 25 FEB 93
**
PALFXGET
	;GET FIRST NODE
	MOVL	@PALFXFREELIST,A0
	TLOCKON	Z
	JRZ	PFXGX

	;UNLINK
	MOVL	*A0,A14
	MOVL	A14,@PALFXFREELIST

PFXGX
	RETS

**
** PALFXPUT
**
** OUT
**   A0 NODE
**
** WARNING: CALLER MUST PROTECT THIS WITH DINT
**
** JFL 25 FEB 93
**
PALFXPUT

	;RE-LINK
	MOVL	@PALFXFREELIST,A14
	MOVL	A14,*A0
	MOVL	A0,@PALFXFREELIST

	RETS

**
** PALCYCLEADD
** NOTE: COUNT SHOULD BE ODD FOR RESULTS
**
** IN
**   A2 VEL.8:COUNT.8:PAL.8:COL.8
**   A3 TIMEDELAY
** SCRATCH: A0-A6
**
** JFL 25 FEB 93
**
PALCYCLEADD
	;
	;CHECK IF SAME RANGE IS ALREADY BEING CYCLED
	;
	MOVL	@PALCYCLELIST,A0
	JRZ	PCANOTFOUND
	MOVE	A2,A4
	ZEXT	A4			;ISOLATE PAL
PCAFLOOP
	MOVW	*A0(PFXFIRST),A1
	ZEXT	A1			;ISOLATE PAL
	CMP	A1,A4
	JREQ	PCAMATCHX
	MOVL	*A0,A0			;NEXT
	JRNZ	PCAFLOOP

PCANOTFOUND
	;
	;ATTACH A NODE FOR RANGE
	;
	GETST	B14
	DINT
	
	;GET A NODE
	CALLR	PALFXGET ;OUT:A0
	JRZ	PCAX
	
	;SET INFO
	MOVL	A2,*A0(PFXFIRST)	
	MOVW	A3,*A0(PFXTIME)
	CLR	A14
	MOVL	A14,*A0(PFXIRQ)

	;LINK IT INTO THE LIST
	MOVL	@PALCYCLELIST,A14
	MOVL	A14,*A0
	MOVL	A0,@PALCYCLELIST

PCAX
	PUTST	B14
PCAMATCHX
	RETS

**
** PALCHECK
** FOR USE IN MAKING SURE THE PALETTE IN CRAM IS THE SAME AS THAT IN ROM
** THIS ROUTINE IS MEANT FOR DEBUGGING ONLY AND NOT TOO ROBUST
**
** IN
**   A2 PALID (I.E. 12H FOR PALETTE 18)
**   A3 PALADR
**
** JFL 14 APR 93
**
PALCHECK
	MMTM	SP,A0,A1,A4,A5

	;SET UP SO WE CAN READ CRAM
	GETST	A5			;DISABLE INTS
	DINT
	
	;WAIT FOR DMA TO FINISH
PCKDMAWAIT
	MOVW	@DMACTRL,A14
	JRN	PCKDMAWAIT
	
	;GET ADR IN CRAM OF THE PAL
	SLL	32-8,A2
	SRL	12,A2
	ADDI	COLRAM,A2

	MOVW	*A3+,A4			;COUNT

PCKLOOP	
	MOVW	*A2+,A0			;CRAM VALUE
	MOVW	*A3+,A1			;ROM VALUE
	CMP	A0,A1
	TLOCKON	NE
	DSJ	A4,PCKLOOP
	
	;RE-ENABLE INTS
	PUTST	A5

	MMFM	SP,A0,A1,A4,A5
	RETS

	.END


* EOF

